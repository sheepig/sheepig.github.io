<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>async/await 异步队列 vs Promise 异步队列</title>
    <url>/2018/11/20/async-await-and-promise/</url>
    <content><![CDATA[<p>我在上一篇<a href="https://www.xqyoung.com/2018/11/20/promise-async-then-chain/">Promise 异步编程</a>里面，提到了一个面试题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span>(<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line"><span class="comment">//todo 补全函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>实现方法，我用了 promise ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span>(<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  ajaxArray.forEach(<span class="function">(<span class="params">ajax</span>) =&gt;</span> &#123;</span><br><span class="line">    p = p.then(ajax).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      result.push(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保持异步队列按顺序调用，我们要维护一条 promise 链，一般就是在函数作用域内生成一个 resolved 的 <code>Promise.resolve()</code>，然后在它后面接上 then 链。于是我们还要分析，then 的回调是不是返回一个异步 resolve 的 promise ？后面需不需要再接上一条 then 的尾巴，以接收异步 resolve 的结果？</p>
<p>promise 不好读，因为 promise 基本是 try、catch 和 return 之类的语言原语的替代品。</p>
<p>我用 async/await 改写一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span>(<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> ajaxArray) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="keyword">await</span> fn();</span><br><span class="line">      result.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> run().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环里面，我们可以像写同步代码一样写异步代码，await 一个异步结果。</p>
<h3 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">生成器函数</a>在执行时能暂停，后面又能从暂停处继续执行。</p>
<p>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （iterator ）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">10</span>;</span><br><span class="line">    y=<span class="keyword">yield</span> <span class="string">'foo'</span>;</span><br><span class="line">    <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g=gen();</span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// 执行 yield 10，返回 10</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// 执行 yield 'foo'，返回 'foo'</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">10</span>));<span class="comment">// 将 10 赋给上一条 yield 'foo' 的左值，即执行 y=10，返回 10</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next());<span class="comment">// 执行完毕，value 为 undefined，done 为 true</span></span><br></pre></td></tr></table></figure>
<p>更多例子查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">MDN 生成器函数</a></p>
<h4 id="generator-异步队列"><a href="#generator-异步队列" class="headerlink" title="generator 异步队列"></a>generator 异步队列</h4><p>以上面的代码为例，每次调用 <code>g.next()</code> 会走到下一个 yield 语句，对 yield 语句后面对表达式求值，并且返回形如 <code>{value: someValue, done: false}</code> 的对象，我们希望在生成器函数里面可以像写同步代码一样，yield 一个异步结果。那么 yield 应该返回一个 Promise 实例，通过控制 g.next() 的执行，只有在上一个 yield 返回的 promise resolve/reject 之后，才调用 g.next() 走到下一个 yield 语句。</p>
<p>我们先有一系列的 promise ，它们是要被异步执行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncPromise = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(x + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> asyncPromise(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> asyncPromise(data1);</span><br><span class="line">  <span class="built_in">console</span>.log(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">yield</span> asyncPromise(data2);</span><br><span class="line">  <span class="built_in">console</span>.log(data3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要一个控制函数，它接受 gen 作为函数，控制执行流程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> carryPromise = <span class="function"><span class="keyword">function</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> g = gen();</span><br><span class="line">    <span class="keyword">const</span> next = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ret = g.next(data);</span><br><span class="line">      <span class="comment">// 走到最后一个 yield 语句，最好把最后一个值传递下去</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ret.value 其实是一个 promise</span></span><br><span class="line">      <span class="comment">// 这里为刚刚生成的 promise 注册 then 回调，回调的操作是注册下一个 promise</span></span><br><span class="line">      ret.value.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        next(data);</span><br><span class="line">        <span class="comment">// 上面这句换成</span></span><br><span class="line">        <span class="comment">// return next(data);</span></span><br><span class="line">        <span class="comment">// 结果也是一样的，就和 Promise 链式调用一样了</span></span><br><span class="line">        <span class="comment">// 只不过实现上，更偏向控制 g.next() 的移动，来实现 promise 的注册</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">carryPromise(gen).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`end with: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每项输出前间隔 1 s</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// end with 4</span></span><br></pre></td></tr></table></figure>
<p>用 generator 实现的异步队列，跟 Promise 的 then 链式回调有些相似，一样是在 promise 的 then 回调里面创建新的 promise ，不一样的是，链式回调的 then 回调里面要 return 这个新的 promise，值才会沿着 then 链传递下去。而 generator 赋给了我们从“外部读取异步结果的能力”，例如 <code>const data1 = yield asyncPromise(1);</code> 。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>首先搞清楚，async 关键字后面跟一个函数，await 关键字后面跟一个表达式，表达式应该是一个 Promise 对象或者任何要等待的值。</p>
<p>当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。</p>
<p>async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待表达式中的 Promise 执行完成后才会继续执行 async 函数并返回解决结果。</p>
<p>更多关于 async function，查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">MDN async function</a></p>
<p>用 async/await 改写 generator 实现的异步队列：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> asyncPromise(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> asyncPromise(data1);</span><br><span class="line">  <span class="built_in">console</span>.log(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data3 = <span class="keyword">await</span> asyncPromise(data2);</span><br><span class="line">  <span class="built_in">console</span>.log(data3);</span><br><span class="line">  <span class="keyword">return</span> data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = fn().then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`end with <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>async function 的返回值将被隐式地传递给 Promise.resolve。</p>
<blockquote>
<p>参考文章 </p>
<p><a href="https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html" target="_blank" rel="noopener">Taming the asynchronous beast with ES7</a></p>
<p><a href="https://juejin.im/post/59cce36751882501c14db49c" target="_blank" rel="noopener">JavaScript 异步队列实现及拓展</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>同步渲染和异步渲染对 DOM 的阻塞</title>
    <url>/2018/11/19/async-render/</url>
    <content><![CDATA[<p>首先区分一下，什么是同步渲染和异步渲染。</p>
<p>同步：浏览器访问网址，浏览器创建新的tabpage，新的内存块，加载页面的全部资源并渲染全部资源。但只要有页面中的任何一个操作，就会从新的开端全部在创建请求渲染一次，浏览器自己控制的http。</p>
<p>异步：用之前已经渲染过的页面数据，与后台交互数据不需要重新来渲染页面，实现对页面的部分更新。这里主要讲动态插入 HTML 标签的异步渲染。</p>
<h3 id="同步渲染"><a href="#同步渲染" class="headerlink" title="同步渲染"></a>同步渲染</h3><p>一般我们会把样式写在 HTML 头部，页面脚本放在 <code>&lt;/body&gt;</code> 之前，因为样式和脚本会阻塞 DOM 渲染，但是样式不阻塞 DOM 解析。</p>
<p>以下是 Webkit 解析资源，最终呈现页面的主流程</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="Webkit&#39;s process"></p>
<h4 id="脚本和样式表的处理顺序"><a href="#脚本和样式表的处理顺序" class="headerlink" title="脚本和样式表的处理顺序"></a>脚本和样式表的处理顺序</h4><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><p>解析 HTML 文件过程中，解析器遇到 <code>&lt;script&gt;</code>标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>
<h5 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h5><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>
<h5 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h5><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>
<hr>
<h4 id="CSS-阻塞-DOM-渲染"><a href="#CSS-阻塞-DOM-渲染" class="headerlink" title="CSS 阻塞 DOM 渲染"></a>CSS 阻塞 DOM 渲染</h4><p>这里需要区分 DOM 解析（parsing）和 DOM 渲染 （rendering）。准确来说，是 HTML Parsing 和 DOM Rendering 。无论是外链 CSS 还是内联 CSS ，都会阻塞 Rendering ，也就是说这部分 CSS 在下载并解析结束之前，它后面的 HTML 都不会显示。这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。</p>
<p>CSS 阻塞 Rendering 的最直接结果，就是延迟脚本执行和 DOMContentLoaded 事件触发。但是，不同的渲染引擎对此处理不一样，Presto (Opera)就不会延迟脚本的执行。</p>
<p>有些情况下，可以尝试添加媒体查询来避免不必要的阻塞。 尤其是响应式站点可以做此优化：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">&lt;link href=<span class="string">"other.css"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"(min-width: 40em)"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>看一个栗子</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h2&gt;Hello&lt;/h2&gt;</span><br><span class="line">  &lt;script&gt; </span><br><span class="line">    <span class="function">function <span class="title">printH2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        console.log(<span class="string">'first script'</span>, document.querySelectorAll(<span class="string">'h2'</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    printH2();</span><br><span class="line">    setTimeout(printH2);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"http://cdn.bootcss.com/bootstrap/4.0.0-alpha.4/css/bootstrap.css"</span>&gt;</span><br><span class="line">  &lt;h2&gt;World&lt;/h2&gt;</span><br><span class="line">  &lt;script&gt; console.log(<span class="string">'second script'</span>); &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在 Chrome 开发者工具中开启 <code>Disable Cache</code> 和 <code>Throttling</code> 来模拟较慢的网络。</p>
<p><img src="render1.png" alt=""></p>
<p><img src="render2.png" alt=""></p>
<p>可以看到 document(HTML) 花了 2.01s 加载，加载完成后，页面还未渲染。</p>
<p>第一次输出只有一个 <code>&lt;h2&gt;</code> ，说明脚本执行会阻塞 DOM 解析。</p>
<p>第二次输出有两个 <code>&lt;h2&gt;</code> ，说明样式不会阻塞 DOM 解析。</p>
<p>控制台已经打印出 <code>h2</code> ，页面还是空白，说明样式会阻塞 DOM 渲染。</p>
<p>2.01s 后，<code>&#39;second script&#39;</code> 没有被打印出来，说明样式会阻塞脚本。</p>
<p>但是一般人不会去 <code>Disable Cache</code> ，那么如果在允许缓存的情况下，样式表已经缓存过，那句 <code>setTimeout(printH2);</code> 还会在样式加载结束后才打印吗？不同渲染引擎对此处理不同，前文有提到，Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。本次实验是在 Chrome 上进行的，反复刷新了几遍后，终于有这样一个结果：</p>
<p><img src="render3.png" alt=""></p>
<hr>
<h4 id="脚本阻塞-DOM-解析-渲染"><a href="#脚本阻塞-DOM-解析-渲染" class="headerlink" title="脚本阻塞 DOM 解析+渲染"></a>脚本阻塞 DOM 解析+渲染</h4><p>同步渲染模式下，无论是内联的脚本还是外链的脚本，都会阻塞 DOM Parsing ，<code>DOMContentLoaded</code> 事件会被延迟，DOM Rendering 自然也被阻塞。由于 JavaScript 只会阻塞后续的 DOM，前面的 DOM 在解析完成后会被立即渲染给用户。 这也是为什么我们把脚本放在页面底部：脚本仍在下载时页面已经可以正常地显示了。</p>
<hr>
<h3 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h3><h4 id="外链样式表"><a href="#外链样式表" class="headerlink" title="外链样式表"></a>外链样式表</h4><p>动态插入的外链样式表不阻塞 DOM Rendering ，当然也不阻塞 DOM Parsing 。</p>
<p>打开一个任何一个页面，在控制台输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">link.rel = <span class="string">'stylesheet'</span>;</span><br><span class="line">link.href = <span class="string">'https://cdn.bootcss.com/animate.css/3.5.2/animate.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.text = <span class="string">'console.log("after link[rel=stylesheet]")'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h2 = <span class="built_in">document</span>.createElement(<span class="string">'h2'</span>);</span><br><span class="line">h2.innerHTML = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(h2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题外话：例子是直接引用参考文章的，文章中外链的 CSS 样式的 Url 里面的协议是 HTTP，在 HTTPS 的网页注入这段代码，外链会被 block 掉。<a href="https://www.jianshu.com/p/c195b4adaec1" target="_blank" rel="noopener">https 页面中引入 http 资源的解决方式</a></p>
</blockquote>
<p>在外链样式表还在下载时，脚本已经执行，文本也已经渲染。</p>
<p><img src="render4.png" alt=""></p>
<hr>
<h4 id="内联样式表"><a href="#内联样式表" class="headerlink" title="内联样式表"></a>内联样式表</h4><p>与外链样式表不同，内联样式表会阻塞DOM解析（当然渲染也会被阻塞）。 其实不能叫阻塞啦，因为不涉及网络请求，内联样式表的解析本来就是同步的。</p>
<p>我们可以通过 <code>document.styleSheets</code> 来检测样式表是否已经解析（Parse）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">style.textContent = <span class="string">'*&#123; color: red &#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.head.innerHTML = <span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.styleSheets.length);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(style);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>].rules[<span class="number">0</span>].cssText);</span><br></pre></td></tr></table></figure>
<p><img src="render5.png" alt=""></p>
<p>第一处 console.log: <code>&lt;style&gt;</code> 尚未插入 DOM 树的时候，样式表的数目为零。</p>
<p>第二处 console.log: 插入 <code>&lt;style&gt;</code> 标签后，立刻读取被解析的 CSS 规则。</p>
<p>总结：</p>
<ul>
<li>未插入 DOM 树的 内联样式不会被解析</li>
<li>插入后样式表会被立即解析，甚至不会进入下一个<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">事件循环</a>。也就是说，<code>document.body.appendChild(style);</code> 执行完之后，进入样式表解析。最后一句 console.log 要一直等待样式解析完成才会执行。如果样式表十分庞大，阻塞将十分明显。</li>
</ul>
<hr>
<h4 id="外链脚本"><a href="#外链脚本" class="headerlink" title="外链脚本"></a>外链脚本</h4><p>动态插入的外部脚本的载入是异步的，不会阻塞解析或者渲染。 这意味着动态插入一个外部脚本后不可立即使用其内容，需要等待加载完毕。 例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'https://cdn.bootcss.com/react/15.4.0/react.js'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after script'</span>, <span class="built_in">window</span>.React);</span><br></pre></td></tr></table></figure>
<p><img src="render6.png" alt=""></p>
<p><code>window.React</code> 会为空，等到外链资源加载完成后才可用。</p>
<h4 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h4><p>内联脚本的表现和内联样式基本一样，阻塞 DOM parsing，阻塞后续脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.text = <span class="string">"console.log('from script');"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before script'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after script'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="render7.png" alt=""></p>
<h4 id="资源载入事件"><a href="#资源载入事件" class="headerlink" title="资源载入事件"></a>资源载入事件</h4><p>脚本和样式载入事件可以直接监听到，当然这只对非阻塞的资源获取有效。 需要注意的是浏览器兼容性：绝大多数情况监听 <code>onload</code> 和 <code>onerror</code> 即可， 为了支持IE浏览器，可以监听 <code>onreadystatechange</code> 事件。</p>
<hr>
<p>总结：</p>
<ul>
<li>未插入到 DOM 树的外链样式/脚本，不会发起网络请求，更不会对 DOM Parsing/Rendering 有什么影响。</li>
<li>同步模式下（文档已自带的 style、script 标签），内联样式表/脚本阻塞 DOM parsing ，外链样式表不阻塞 DOM parsing，但是阻塞 DOM rendering ；没有 async，defer 等标记的“裸奔”外链脚本，阻塞 DOM parsing 。</li>
<li>异步模式下（动态添加 style、script 标签）外链样式表/脚本不阻塞 DOM Parsing 和 DOM Rendering 。这意味着要等它们下载完才可用。内联样式表/脚本阻塞 DOM Parsing/Rendering ，阻塞后续脚本（不会进入事件循环，这一点和同步模式一样）。</li>
</ul>
<hr>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>外链样式脚本放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中，因为外链样式不阻塞 DOM 解析，这样做也可以避免样式跳动。</li>
<li>对整个页面样式的调整（会触发回流）如调整 rem 计算策略的 script 脚本，可以放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中，这里可以用内联的方法（虽然不是最佳），阻塞后续 DOM 解析，避免样式跳动。也可以用外链脚本， 加上 <code>async</code> 标签可以让脚本的下载不占用 DOM 解析线程，在下载完后立刻执行。</li>
<li>使用 CDN 。不局限于样式和脚本，图片也可以。</li>
<li>样式、图片使用外域，因为浏览器有最大并行下载数限制。解析见<a href="https://webmasters.stackexchange.com/questions/26753/why-do-big-sites-host-their-images-css-on-external-domains" target="_blank" rel="noopener">Why do big sites host their images/css on external domains?</a></li>
<li><code>async</code> <code>defer</code> <code>preload</code> <code>prefetch</code>。前两个只能作用于脚本</li>
</ul>
<p><img src="https://image-static.segmentfault.com/215/179/2151798436-59da4801c6772_articlex" alt="async vs defer"></p>
<p>没有标记加载策略的 <code>script</code> 和 <code>async</code> 都会阻塞 DOM 解析，不同在于 <code>async</code> 的下载相对于 DOM 解析是异步的。<code>defer</code> 的下载也是异步的，但是下载结束后不立刻执行，而且还会按照 <code>script</code> 标签的顺序执行。（这一点 <code>async</code> 就不能保证）。</p>
<blockquote>
<p>参考文章<br><a href="https://harttle.land/2016/11/26/static-dom-render-blocking.html" target="_blank" rel="noopener">CSS/JS 阻塞 DOM 解析和渲染</a><br><a href="https://harttle.land/2016/11/26/dynamic-dom-render-blocking.html" target="_blank" rel="noopener">异步渲染的下载和阻塞行为</a><br><a href="http://www.qingpingshan.com/m/view.php?aid=169704" target="_blank" rel="noopener">异步渲染DOM元素的加载时机</a><br><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets" target="_blank" rel="noopener">How Browsers Work: Behind the scenes of modern web browsers #The order of processing scripts and style sheets</a><br><a href="https://mp.weixin.qq.com/s/5cnZ9_67-Ikwg4GQ-2nhuw" target="_blank" rel="noopener">有一种优化，叫Preload</a><br><a href="https://cloud.tencent.com/document/product/228/2939#.E5.8A.A0.E9.80.9F.E5.8E.9F.E7.90.86" target="_blank" rel="noopener">Tencent CDN</a></p>
</blockquote>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>渲染</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器事件机制</title>
    <url>/2018/11/20/browser-dom-event/</url>
    <content><![CDATA[<p>要知道浏览器是怎么接收输入（滚动，鼠标移动，input 事件，对浏览器来说都是输入），需要明白在页面的呈现的哪个步骤，对事件作出响应。</p>
<p>简单讲一下页面呈现步骤：</p>
<p>浏览器的 render process 构建了 DOM Tree，CCSOM tree ，它知道文档的结构以及每个节点的样式，但仅有这些信息不足以渲染一个页面。这时需要 layout process 去定位每个节点的几何信息（形状，位置），由 render process 提供的 DOM tree 和 CSSOM tree ，构建 layout tree （或者说 render tree）。下一步交给 painting process ，主线程遍历 layout tree ，创建画板记录（paint records）。画板记录就像是 painting process 中的一本笔记，记录着类似“先画背景，然后是文字，然后是矩形”的东西。</p>
<p>现在浏览器知道了文档的结构，节点的样式，页面的几何信息，还有绘制顺序。把这些信息转化为屏幕上的像素的过程，叫做光栅化。</p>
<p>比较傻瓜的方法是在浏览器的视口（viewport）里面做部分光栅化。如果用户滚动页面，把这个光栅往下挪，填充空缺的部分。Chrome 刚发布的那会就是用这种方式做光栅化的，现代浏览器则会启用一个更复杂的进程：compositing（合成）。</p>
<p>compositing 进程把页面分为多个图层（layer），分隔地将它们光栅化，最后在合成器线程（compositor thread）中组成页面。图层可能很大，比如占据整个页面的长度，所以合成器线程会把它们分成一个个小瓦片，发送到多个光栅线程（raster threads）。光栅线程将每个瓦片光栅化（像素化），并储存在 GPU 内存中。</p>
<blockquote>
<p>在 chrome devTools 里面的 performance 可以看到，渲染一个页面的时候有多个 raster threads 参与。</p>
</blockquote>
<p>以上大概就是页面 layout –&gt; paint –&gt; composite 的过程，更多细节可以看 google developers 的文章 <a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3" target="_blank" rel="noopener"><br>Inside look at modern web browser (part 3)</a></p>
<hr>
<p>好了，终于可以讲浏览器对输入的处理了：</p>
<p>第一个接收到用户手势（触屏，点击，滑动…）的是浏览器进程（UI 线程？），浏览器进程会把这个手势的事件类型，坐标发送到渲染进程。渲染进程找到事件目标，执行对应的监听。</p>
<p>执行 JavaScript 是主线程（main thread）的主要工作，当一个页面经由合成器线程合成后，合成器线程会把绑定了监听事件的区域标记为 “Non-Fast Scrollable Region” 。如果注册的事件在这个区域上触发，合成器线程确保把事件发送到主线程。如果事件发生在这个区域外，合成器线程继续合成新的帧，而不用等待主线程。</p>
<p>我们知道事件代理模式。事件可以冒泡，那么可以在最最底部的元素上绑定事件，比如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchstart'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.target === area) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>看起来只需要注册一次事件，就可以代理所有发生在它子代上面的事件，似乎很诱人。但是在浏览器的角度，整个页面被标记为 non-fast scrollable region ，这意味着，尽管你的应用可能不在意页面一些区域的输入，合成器线程还是需要和主线程通信，每次都要等待输入。所以合成器的“顺畅滚动“能力用不上了。</p>
<p>可以向事件监听传入参数 <code>passive: true</code> ，这告诉浏览器：你还是想要在主线程上监听事件，但是合成器线程仍继续合成帧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchstart'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.target === area) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, &#123;<span class="attr">passive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="事件触发的三个阶段"><a href="#事件触发的三个阶段" class="headerlink" title="事件触发的三个阶段"></a>事件触发的三个阶段</h3><p>本节部分转载自： <a href="https://yuchengkai.cn/docs/zh/frontend/browser.html#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">https://yuchengkai.cn/docs/zh/frontend/browser.html#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6</a></p>
<p>事件触发有三个阶段</p>
<ul>
<li>window 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般按照上面的顺序，但是有例外：如果为同一个元素同时注册了捕获事件和冒泡事件，事件会按照注册的顺序触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>一般用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">EventTarget.addEventListener()</a>，当然 ie 老古董自行用 <code>onEvent = function(){ ... }</code> 方式。</p>
<p>addEventListener 函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。缺省情况下注册冒泡事件。</p>
<p>对于对象参数来说，可以使用以下几个属性</p>
<ul>
<li>capture，布尔值，和 useCapture 作用一样</li>
<li>once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听</li>
<li>passive，布尔值，表示永远不会调用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" target="_blank" rel="noopener">preventDefault</a></li>
</ul>
<p>capture 和 once 都比较好理解。下面讲一下 preventDefault ：</p>
<p>preventDefault 告诉浏览器：如果此事件没有需要显式处理，那么它默认的动作也不要做（因为默认是要做的）。此事件还是继续传播，除非碰到事件侦听器调用stopPropagation() 或stopImmediatePropagation()，才停止传播。</p>
<p>这里我们可以看到 preventDefault 的作用：开发者可以在监听 touch 和 wheel 事件时指定 <code>{passive:true}</code> 来表明他们不会调用preventDefault。也就是说，默认的滚动事件还是要做的，而且永远不会被禁用，从而获得更好的滚动性能。归根结底是合成器线程无需等待主线程，继续合成帧。</p>
<p>更多阅读移步 <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md" target="_blank" rel="noopener">Passive event listeners</a> <a href="https://futu.im/posts/2017-06-06-passive-event-listeners/" target="_blank" rel="noopener">翻译版</a></p>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ul"</span>&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;4&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">5</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'##ul'</span>)</span><br><span class="line">    ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.target);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie 基础概念</title>
    <url>/2018/11/20/cookie-base-concept/</url>
    <content><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>我们常说的 cookie ，也称为 HTTP Cookie ，它其实是 HTTP 头部中的一段信息，记录客户端和服务器端的交互中的一些信息。它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><p><a href="https://tools.ietf.org/html/rfc6265#section-4.1" target="_blank" rel="noopener">RFC 6265</a> 规定，服务端可以在 HTTP 响应头部设置 cookie。格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie:&lt;cookie&gt;</span><br></pre></td></tr></table></figure>
<p>cookie 以一对键-值对开始，后面跟着若干属性-值对。属性的详细信息查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">MDN Set-Cookie</a>。</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>value</th>
<th>detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>Expires</td>
<td>符合 HTTP-date 规范的时间戳</td>
<td>若不设置，说明这是一个会话期 cookie</td>
</tr>
<tr>
<td>Max-Age</td>
<td>cookie 存活的时间，单位是秒。</td>
<td>优先级比 Expires 高</td>
</tr>
<tr>
<td>Domain</td>
<td>cookie 可以送达的主机名</td>
<td>假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）</td>
</tr>
<tr>
<td>Path</td>
<td>指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</td>
<td>字符  %x2F (“/“) 可以解释为文件目录分隔符，此目录的下级目录也满足匹配的条件（例如，如果 path=/docs，那么 “/docs”, “/docs/Web/“ 或者 “/docs/Web/HTTP” 都满足匹配的条件）。如果没有设置这个值，用户代理会默认使用 HTTP 请求 URI 的 path</td>
</tr>
<tr>
<td>Secure</td>
<td>只有在浏览器认为当前通道是“安全”的，才会把带有 Secure 选项的 cookie 发送到服务端</td>
<td>浏览器认为的安全，通常是在 HTTPS 下</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由  Document.cookie 属性、XMLHttpRequest 和  Request APIs 进行访问，以防范跨站脚本攻击（XSS）</td>
</tr>
</tbody>
</table>
<p>一个 Set-Cookie 首部字段，只能设置一个 cookie，如果要设置多个 cookie ，直接用多个 Set-Cookie 字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie:&lt;cookie1&gt;</span><br><span class="line">Set-Cookie:&lt;cookie2&gt;</span><br></pre></td></tr></table></figure>
<h3 id="cookie的读写"><a href="#cookie的读写" class="headerlink" title="cookie的读写"></a>cookie的读写</h3><p>原生 node 的 res.setHeader 和 res.writeHead ，如果直接对 Set-Cookie 赋值，会出现覆盖的情况。其实也好理解，对对象的某个属性重复写入值，只有最后一个会保留。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"yang=ozz; Max-Age=500"</span>);</span><br></pre></td></tr></table></figure>
<p>要在 HTTP 头部加入多个 Set-Cookie 字段，需要对响应流拼接多个 Set-Cookie 选项。为了节省时间，这里用 express 。</p>
<p>设置以下 cookie</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: yan=eee; Max-Age=600; Path=/; Expires=Invalid Date</span><br><span class="line">Set-Cookie: agg=sss; Max-Age=600; Path=/; Expires=Invalid Date</span><br></pre></td></tr></table></figure>
<p>通过 document.cookie 或直接在浏览器 Application 面板中，可以直接访问，修改 cookie 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie // &quot;yan=eee; agg=sss&quot;</span><br><span class="line">document.cookie = &quot;yan=www&quot;;</span><br><span class="line">document.cookie // &quot;agg=sss; yan=www&quot;</span><br></pre></td></tr></table></figure>
<p>document.cookie 修改 cookie 只能一个个修改，格式和 Set-Cookie 一样。没有指定修改的属性保持不变，修改的值便覆盖原来的值。</p>
<h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p>HttpOnly 只能由服务端设置，本地的设置不会生效。而且设置了 HTTPOnly 的 cookie 无法通过 document.cookie 访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: yan=eee; Max-Age=600; Path=/; Expires=Invalid Date; HttpOnly</span><br><span class="line">Set-Cookie: agg=sss; Max-Age=600; Path=/; Expires=Invalid Date</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie // &quot;agg=sss&quot;</span><br></pre></td></tr></table></figure>
<h3 id="cookie-删改"><a href="#cookie-删改" class="headerlink" title="cookie 删改"></a>cookie 删改</h3><p>修改 cookie</p>
<p>要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path/domain这几个选项一定要旧cookie 保持一样。否则不会修改旧值，而是添加了一个新的 cookie。</p>
<p>删除 cookie</p>
<p>删除一个cookie 也挺简单，也是重新赋值，只要将这个新cookie的expires 选项设置为一个过去的时间点就行了。但同样要注意，path/domain/这几个选项一定要旧cookie 保持一样。</p>
<p>原生的 cookie 的读写接口都不太友好，一般需要封装方法。</p>
<ul>
<li>读取 cookie</li>
</ul>
<p>document.cookie 的结果是一串字符串，是以“; ”分隔开的 cookie 键值对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ary = <span class="built_in">document</span>.cookie.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^| )"</span> + name + <span class="string">"=([^;]*)(;|$)"</span>));</span><br><span class="line">    <span class="comment">// 第二个捕获组就是 key=value; 的 value</span></span><br><span class="line">    <span class="keyword">return</span> ary[<span class="number">2</span>] ? ary[<span class="number">2</span>] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getCookie(<span class="string">'agg'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// options</span></span><br><span class="line"><span class="comment">// |-- expires  自设置起过期秒数</span></span><br><span class="line"><span class="comment">// |-- callback 设置成功后回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">    options = options ? options : &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> exp = <span class="keyword">new</span> Data();</span><br><span class="line">    <span class="keyword">var</span> expire = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (options.expires) &#123;</span><br><span class="line">        exp.setTime(exp.getTime + expires * <span class="number">1000</span>);</span><br><span class="line">        expire = exp.toGMTString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + <span class="built_in">escape</span>(value) + <span class="string">";path=/;expires="</span> + expire;</span><br><span class="line">    options.callback &amp;&amp; options.callback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>客户端储存</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Houdini</title>
    <url>/2018/11/21/css-Houdini/</url>
    <content><![CDATA[<p>借用<a href="https://developers.google.com/web/updates/2016/05/houdini" target="_blank" rel="noopener">谷歌开发者文档</a>的比喻，CSS Houdini 允许你自己当一名魔术师——传统流程中，你改变了 css 的一个样式，可能整个页面的样式都大变样，但是你只能看着浏览器呈现这场魔法盛宴，自己无法参与。CSS Houdini 赋予了你魔术师的本领，你也可以参与浏览器处理样式和布局的流程。</p>
<p>Houdini 是 W3C 新成立的一个任务小组，它的终极目标是实现 css 属性的完全兼容。Houdini 提出了一个前无古人的的设想：开放 CSS 的 API 给开发者，开发者可以通过这套接口自行扩展 CSS，并提供相应的工具允许开发者介入浏览器渲染引擎的样式和布局流程中。</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><h4 id="Worklets"><a href="#Worklets" class="headerlink" title="Worklets"></a>Worklets</h4><p>此规范定义了一个 API ，规范了渲染流程中的各个阶段运行的独立于主 javascript 执行环境的脚本。Worklets 的概念和 Web Worker 相似，它们允许你引入脚本文件并执行特定的 JS 代码。Worklets 和 Web Worker 有很多概念上的重叠，那么搞出一个 Worklets 是否多此一举？</p>
<p>Worklets ，后缀 <code>-let</code> 已经表面了它的特性“小”。存在这种可能：脚本中某些代码片段，在每一帧都要跑一次。Web Worker 其实比较笨重，并不鼓励大量使用。举个例子，为一张四百万像素的图片的每一个像素启用一个 Web Worker 将是不妥当的。</p>
<p>Worklets 定义了一个方法集合，这些方法的特性由 Worklets 的类型预定义了，开发者所能执行的操作类型被限定，这样就保证了性能。</p>
<h4 id="CSS-Paint-API"><a href="#CSS-Paint-API" class="headerlink" title="CSS Paint API"></a>CSS Paint API</h4><p>Paint API 在 Chrome 65 默认开启支持，它也被称为 “Houdini’s paint worklet”，它允许 Web 开发人员使用 JavaScript 自定义 CSS <code>image</code>（背景，边框，内容），自定义的 <code>image</code> 会响应样式和尺寸的变化。 </p>
<p>下面是<a href="https://developers.google.com/web/updates/2018/01/paintapi" target="_blank" rel="noopener">谷歌开发者文档</a>给的一个例子。</p>
<p>在 Worklets 脚本文件中，先定义一个 CheckerboardPainter 的类，里面规定了画棋盘的方法。然后用 <code>registerPaint</code> 方法注册一个 paint worklet 类。这个 paint worklet 名为 checkerboard 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// checkerboard.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckerboardPainter</span> </span>&#123;</span><br><span class="line">  paint(ctx, geom, properties) &#123;</span><br><span class="line">    <span class="comment">// Use `ctx` as if it was a normal canvas</span></span><br><span class="line">    <span class="keyword">const</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">    <span class="keyword">const</span> size = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; geom.height/size; y++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; geom.width/size; x++) &#123;</span><br><span class="line">        <span class="keyword">const</span> color = colors[(x + y) % colors.length];</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.fillStyle = color;</span><br><span class="line">        ctx.rect(x * size, y * size, size, size);</span><br><span class="line">        ctx.fill();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register our class under a specific name</span></span><br><span class="line">registerPaint(<span class="string">'checkerboard'</span>, CheckerboardPainter);</span><br></pre></td></tr></table></figure>
<p>在主 javaScript 环境中，用 <code>CSS.paintWorklet.addModule(&#39;checkerboard.js&#39;)</code> 加载这个 paint worklet ，然后在 css 属性值里面，可以调用 <code>paint(checkerboard)</code> ，就可以定义自己要的 css 背景/边框/内容 效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  textarea &#123;</span><br><span class="line">    background-image: paint(checkerboard);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;textarea&gt;&lt;/</span>textarea&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  CSS.paintWorklet.addModule(<span class="string">'checkerboard.js'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://googlechromelabs.github.io/houdini-samples/paint-worklet/checkerboard/" target="_blank" rel="noopener">在线 demo</a></p>
<h4 id="Animation-Worklet"><a href="#Animation-Worklet" class="headerlink" title="Animation Worklet"></a>Animation Worklet</h4><p>Animation Worklet 是 Compositor Worklet 演化而来的。详细的资料看<a href="https://dassur.ma/things/animworklet/" target="_blank" rel="noopener">这里</a>。</p>
<p>Compositor Worklet 允许开发者书写在合成器线程（compositor thread）。这将保证代码在每一帧运行，并且开启了一些新的可能性，例如强制实现一些和不是绑定在时间上的动画，比如输入或滚动位置。</p>
<p>如果合成器线程阻塞了——因为代码计算量太大或者低效——那么整个页面将无法响应，动画也会卡住。</p>
<p>Animation Worklet 不运行在合成器线程“上”，而是在“尽力而为”的基础上与它同步运行。这意味着，如果你在你的 worklet 中堵塞了，动画允许“溜走”。</p>
<p>预计 Chrome 71 首次尝试支持 Animation Worklet，我写这篇文的时候，Chrome 71还未发布。Animation Worklet 的例子可以看<a href="https://developers.google.com/web/updates/2018/10/animation-worklet" target="_blank" rel="noopener"><br>Houdini’s Animation Worklet</a>。有 <a href="https://github.com/web-animations/web-animations-js" target="_blank" rel="noopener">polyfill</a> 提供一样的 API，但不提供一样的性能。</p>
<h4 id="Layout-Worklet"><a href="#Layout-Worklet" class="headerlink" title="Layout Worklet"></a>Layout Worklet</h4><p>开发者可以自己定义一个布局，自定义盒子内元素的布局，然后用类似 <code>display: layout(myLayout)</code> 这样的规则应用自己的布局。这样的好处是：一方面当有新的布局出现的时候可以借助这个 API 进行 polyfill 就不用担心没有实现的浏览器不兼容，另一方面可以发挥想象力实现自己想要的布局，这样在布局上可能会百花齐放了，而不仅仅使用W3C给的那几种布局。</p>
<h4 id="Typed-CSSOM"><a href="#Typed-CSSOM" class="headerlink" title="Typed CSSOM"></a>Typed CSSOM</h4><p>在 js 中修改一个 css 属性，可谓要翻山越岭：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#someDiv'</span>).style.height = getRandomInt() + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure>
<p>我们做了数学计算，把一个数字转成字符串并附加一个单位，浏览器再解析这个字符串，得到一个数字，再把这个数字交回给 CSS 引擎。</p>
<p>有了类型化 CSS 对象模型，我们可以基于 StylePropertyMap 操作元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style=<span class="string">"width: 200px;"</span> id=<span class="string">"div1"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=<span class="string">"width: 300px;"</span> id=<span class="string">"div2"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"div3"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=<span class="string">"margin-left: calc(5em + 50%);"</span> id=<span class="string">"div4"</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> w1 = $(<span class="string">'#div1'</span>).styleMap.get(<span class="string">'width'</span>);</span><br><span class="line"><span class="keyword">var</span> w2 = $(<span class="string">'#div2'</span>).styleMap.get(<span class="string">'width'</span>);</span><br><span class="line">$(<span class="string">'#div3'</span>).styleMap.set(<span class="string">'background-size'</span>,</span><br><span class="line">  [<span class="keyword">new</span> SimpleLength(<span class="number">200</span>, <span class="string">'px'</span>), w1.add(w2)])</span><br><span class="line">$(<span class="string">'#div4'</span>)).styleMap.get(<span class="string">'margin-left'</span>)</span><br><span class="line">  <span class="comment">// =&gt; &#123;em: 5, percent: 50&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章<br><a href="https://zhuanlan.zhihu.com/p/20939640" target="_blank" rel="noopener">Houdini：CSS 领域最令人振奋的革新
</a><br><a href="https://developers.google.com/web/updates/2016/05/houdini" target="_blank" rel="noopener">Houdini: Demystifying CSS</a></p>
</blockquote>
]]></content>
      <categories>
        <category>css 进阶</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css 动画和硬件加速</title>
    <url>/2018/11/19/css-animation-and-gpu-accelerated/</url>
    <content><![CDATA[<h2 id="什么是动画"><a href="#什么是动画" class="headerlink" title="什么是动画"></a>什么是动画</h2><p>浏览器的动画原理和翻页动画类似，通过不断更新绘制 DOM 和 CSS 形成的动画，绘制的速度够快，人眼就察觉不出每一帧的间隔，视觉上就是连续的动画。大部分浏览器的刷新频率为 60Hz ，也就是一秒 60 帧。setInterval 或 setTimeout 做的动画根据人为定义的时间间隔绘制，如果间隔定义小于浏览器显示频率（16.7ms）假设为10ms，就会导致第三帧丢失。</p>
<a id="more"></a>
<p><img src="http://www.mrfront.com/wp-content/uploads/2016/09/flip-animation-1.gif" alt="animation"></p>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>在 css transition 之前，css 是没有时间轴的，也就是说，所有的状态变化，在一瞬间完成。有了 transition 之后，可以定义一个控件从一个状态过渡到另一个状态的“过渡过程”，浏览器会在过渡过程中填充一连串连续帧。transition 要求控件有明确的开始状态和结束状态，比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</p>
<p>过渡效果被限制在始末两个状态，这决定了它们会缺少动效那样的细节处理，但同时它实现起来也更容易。</p>
<h3 id="使用-transition"><a href="#使用-transition" class="headerlink" title="使用 transition"></a>使用 transition</h3><p>CSS transitions 可以决定哪些属性发生动画效果 (明确地列出这些属性)，何时开始 (设置 delay），持续多久 (设置 duration) 以及如何动画 (定义timing funtion，比如匀速地或先快后慢)。</p>
<p>并不是所有的 css 属性都可以动画。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties" target="_blank" rel="noopener">可动画属性列表</a>是一个有限集合。</p>
<p>定义一个过渡效果，有以下 css 属性：</p>
<ul>
<li>transition-property 指定哪个或哪些 CSS 属性用于过渡。只有指定的属性才会在过渡中发生动画，其它属性仍如通常那样瞬间变化。</li>
<li>transition-duration 指定过渡的时长。或者为所有属性指定一个值，或者指定多个值，为每个属性指定不同的时长。</li>
<li>transition-timing-function 指定一个函数，定义属性值怎么变化。缓动函数 Timing functions 定义属性如何计算。</li>
<li>transition-delay 指定延迟，即属性开始变化时与过渡开始发生时之间的时长。</li>
</ul>
<p>简写语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">transition: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>transition 有许多限制，比如：</p>
<ul>
<li>控件的状态只有两个：开始状态和结束状态</li>
<li>transition 的具体动画效果是绑定在具体控件上的，如果想要为多个元素声明同样的 transition ，需要为所有元素书写 transition 属性。</li>
<li>过渡效果需要事件触发，如 hover，元素淡入淡出。</li>
<li>transition 一般只发生一次，不会重复触发。</li>
</ul>
<p>animation（动效） 则可以解决以上问题。动效可以让你添加很多中间状态，并提供了更高的控制程度，而不必依赖于始末两个状态。</p>
<h3 id="使用-animation"><a href="#使用-animation" class="headerlink" title="使用 animation"></a>使用 animation</h3><p>动效是通过对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes" target="_blank" rel="noopener">keyframes（关键帧）</a>的使用设置实现的。过渡效果能在一个类中的一行被指定，而动效能在 CSS 里单独用一系列关键帧被指定。</p>
<p>定义动效的 css 属性：</p>
<ul>
<li>animation-name 指定应用的一系列动画，每个名称代表一个由 @keyframes 定义的动画序列。</li>
<li>animation-duration 指定一个动画周期的时长。默认值是 0s ，表示无动画。</li>
<li>animation-timing-function 定义CSS动画在每一动画周期中执行的节奏。可能值为一或多个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/timing-function" target="_blank" rel="noopener"><timing-function></timing-function></a>。</li>
<li>animation-delay 定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。默认值 0s 代表动画在应用到元素上后立即开始执行。</li>
<li>animation-iteration-count 定义动画在结束前运行的次数。可以是1次，可以是无限循环。默认值是 1 。</li>
<li>animation-direction 指示动画是否反向播放。</li>
<li>animation-fill-mode 指定在动画执行之前和之后如何给动画的目标应用样式。</li>
<li>animation-play-state 定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。默认值是 running 。</li>
</ul>
<p>当相关 animation 属性不多，可以简写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">animation: &lt;name&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt; &lt;iteration-count&gt; &lt;direction&gt;</span><br></pre></td></tr></table></figure>
<h3 id="js-动画"><a href="#js-动画" class="headerlink" title="js 动画"></a>js 动画</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame()</a> 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>
<h2 id="动画和性能"><a href="#动画和性能" class="headerlink" title="动画和性能"></a>动画和性能</h2><p>关于 css 硬件加速，查到的资料大概都是16年之前的（那时的 Chrome 还有 Timeline 面板=。=现在应该叫 Performance 了）。<br>资料如下：</p>
<blockquote>
<p><a href="http://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/" target="_blank" rel="noopener">CSS硬件加速的好与坏</a></p>
<p><a href="https://www.aliyun.com/jiaocheng/664245.html" target="_blank" rel="noopener">CSS动画之硬件加速</a></p>
</blockquote>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">css 层叠上下文</a> 或者说图层，是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p>
<ul>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ul>
<p>每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</p>
<h3 id="top-absolute-实现的动画"><a href="#top-absolute-实现的动画" class="headerlink" title="top + absolute 实现的动画"></a>top + absolute 实现的动画</h3><p>我写了一个 <a href="https://codepen.io/sheepig-the-bashful/full/ZMNbJM" target="_blank" rel="noopener">demo</a>，点击 click ，盒子的 left 变为 200px 。transition 定义的过渡。</p>
<p><img src="transition-repaint.png" alt="transition repaint"></p>
<p>动画的执行的过程中，发生了多次 repaint 。</p>
<p><img src="transition-absolute.png" alt="transition using absolute"></p>
<p>查看主线程，主线程做了很多次 paint 。</p>
<p><img src="main-paint.png" alt="paint"></p>
<p>如果在 chrome 开发者工具中开启 Rendering 面板的 “Painting flashing”，页面中 repaint 区域会被绿色蒙板高亮出来。可以看到动画过渡过程中，灰色盒子有一层闪烁的绿色蒙板。</p>
<p><img src="green-cover.png" alt="green cover"></p>
<p>绝对定位会建立一个新的图层，而此图层上只有当前一个元素，多以只会 repaint ，而不会 reflow 。</p>
<p>在这个例子中，对于动画的每一帧，浏览器会计算元素的几何形状，渲染新状态的图像，并把它们发送给GPU。尽管浏览器做了优化，在repaint时，只会repaint部分区域，但是我们的动画仍然不够流畅。如果这时在主线程运行一些耗时的任务，动画的帧数可能远达不到 60 帧，甚至低于人眼对帧数的分辨率，视觉上出现“卡顿”效果。</p>
<h3 id="transform-实现的动画"><a href="#transform-实现的动画" class="headerlink" title="transform 实现的动画"></a>transform 实现的动画</h3><p>用 transform 改写上面的例子，得到渲染过程如下：</p>
<p><img src="transition-transform.png" alt="transition transform"></p>
<p>显然浏览器花在 paint 的时间少的不止一星半点，动画演示期间并没有过多的 repaint 。简单说，<a href="https://csstriggers.com/transform" target="_blank" rel="noopener">transform</a> 不触发几何变化和绘制，它可以在 GPU 加速下，在 <strong>合成器线程（compositor thread）</strong> 中处理。</p>
<h3 id="GPU-加速"><a href="#GPU-加速" class="headerlink" title="GPU 加速"></a>GPU 加速</h3><p>浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树构建完之后，浏览器要做的就是：reflow/layout -&gt; repaint -&gt; composite 。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理。图层在 GPU 中 transform 是不会触发 repaint 的，最终这些使用 transform 的图层都会由独立的合成器线程进行处理。</p>
<p>现代浏览器大都可以利用GPU来加速页面渲染。在GPU的众多特性之中，它可以存储一定数量的纹理（一个矩形的像素点集合）并且高效地操作这些纹理（比如进行特定的移动、缩放和旋转操作）。这些特性在实现一个流畅的动画时特别有用。浏览器不会在动画的每一帧都绘制一次，而是生成DOM元素的快照，并作为GPU纹理（也被叫做层）存储起来。之后浏览器只需要告诉GPU去转换指定的纹理来实现DOM元素的动画效果。这就叫做GPU合成，也经常被称作『硬件加速』。</p>
<p>所以产生 GPU 加速的条件如下：</p>
<ol>
<li><p>动画会使它所在的元素提升为复合层（一个层叠上下文，比如绝对定位和 transform ），因此不发生 reflow 。</p>
</li>
<li><p>图层在 GPU 中不引起 repaint ，【目前只有 transform 和 opacity】，因此不发生 repaint 。</p>
</li>
</ol>
<p>另外，transform3D 和 2D 的区别在于 3D 渲染前便会产生新的图层，而 2D 是在运行时产生图层，运行结束时删除图层。</p>
<p>浏览器将a元素提升为一个复合层有很多种原因，下面列举了一些：</p>
<ul>
<li><p>3d或透视变换css属性，例如translate3d,translateZ等等（js一般通过这种方式，使元素获得复合层）</p>
</li>
<li><p><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素。</p>
</li>
<li><p>混合插件（如flash）。</p>
</li>
<li><p>元素自身的 opacity 和 transform 做 CSS 动画。</p>
</li>
<li><p>拥有css过滤器的元素。</p>
</li>
<li><p>使用will-change属性。</p>
</li>
<li><p>绝对定位</p>
</li>
<li><p>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</p>
</li>
</ul>
<h2 id="GPU-加速可能带来的问题"><a href="#GPU-加速可能带来的问题" class="headerlink" title="GPU 加速可能带来的问题"></a>GPU 加速可能带来的问题</h2><h3 id="GPU是如何合成图像的"><a href="#GPU是如何合成图像的" class="headerlink" title="GPU是如何合成图像的"></a>GPU是如何合成图像的</h3><p>GPU实际上可以看作一个独立的计算机，它有自己的处理器和存储器及数据处理模型。当浏览器向GPU发送消息的时候，就像向一个外部设备发送消息。</p>
<p>你可以把浏览器向GPU发送数据的过程，与使用ajax向服务器发送消息非常类似。想一下，你用ajax向服务器发送数据，服务器是不会直接接受浏览器的存储的信息的。你需要收集页面上的数据，把它们放进一个载体里面（例如JSON），然后发送数据到远程服务器。</p>
<p>同样的，浏览器向GPU发送数据也需要先创建一个载体；只不过GPU距离CPU很近，不会像远程服务器那样可能几千里那么远。但是对于远程服务器，2秒的延迟是可以接受的；但是对于GPU，几毫秒的延迟都会造成动画的卡顿。</p>
<p>浏览器向GPU发送的数据载体是什么样？这里给出一个简单的制作载体，并把它们发送到GPU的过程。</p>
<ul>
<li><p>画每个复合层的图像</p>
</li>
<li><p>准备图层的数据</p>
</li>
<li><p>准备动画的着色器（如果需要）</p>
</li>
<li><p>向GPU发送数据</p>
</li>
</ul>
<p>所以你可以看到，每次当你添加transform:translateZ(0)或will-change：transform给一个元素，你都会做同样的工作。重绘是非常消耗性能的，在这里它尤其缓慢。在大多数情况，浏览器不能增量重绘。它不得不重绘先前被复合层覆盖的区域。</p>
<h3 id="隐式合成"><a href="#隐式合成" class="headerlink" title="隐式合成"></a>隐式合成</h3><p><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener">https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/</a></p>
<blockquote>
<p>参考文章</p>
<p><a href="https://cssanimation.rocks/transition-vs-animation/" target="_blank" rel="noopener">Transitions vs Animations</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener">CSS动画简介</a></p>
<p><a href="https://juejin.im/post/5afaea6b6fb9a07aa34a6a74" target="_blank" rel="noopener">[译] JavaScript 是如何工作的：CSS 和 JS 动画背后的原理 + 如何优化性能</a></p>
<p><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener">CSS GPU Animation: Doing It Right</a></p>
</blockquote>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>硬件加速</tag>
      </tags>
  </entry>
  <entry>
    <title>css 居中那点事</title>
    <url>/2018/11/20/css-middle-util/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.xqyoung.com/2018/11/20/css-selector/">css width, height, margin 的计算</a></p>
</blockquote>
<h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><p>子元素可能是块级元素，行内不可替换元素，行内可替换元素（以 img 元素为例）。</p>
<p>后面的样式基于下面的 html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="margin-left-margin-right"><a href="#margin-left-margin-right" class="headerlink" title="margin-left + margin-right"></a>margin-left + margin-right</h4><p>一般来说，我们会给块级元素设定 width （width 为 auto 的话会被计算为撑满包含块，那就无所谓“居中”了）。最常用水平居中就是 <code>margin: 0 auto</code> 。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">20px</span>; <span class="comment">/* width: 40%; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子元素定位是 relative 或 static 的情况下，会把第一个块级元素作为自己的包含块。处于文档流的子元素的左右 margin 会被计算为相等数值，这是居中的依据。</p>
<p>这种居中方法可以居中块级元素。对于 img 稍做处理：在外部包裹上一层 div ，让 img 的 width 等于这层 div 的 100% 。img 加上包裹的 div ，就是一个块，适用本条居中原则。</p>
<p>类似的，height 属性可以这么做吗？然而 <code>margin: auto 0</code> 并不会垂直居中任何东西，因为 height 属性的计算法则里面，文档流中的元素，auto 值的上下 margin 会被计算为 0 。 </p>
<h4 id="absolute-margin-left-transform"><a href="#absolute-margin-left-transform" class="headerlink" title="absolute + margin-left/transform"></a>absolute + margin-left/transform</h4><p>子元素是绝对定位的条件下，需要打破原先的包含块 position 的 static 定位（一般用 relative ）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">margin-left</span>: -<span class="number">30px</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子元素定宽（显示指定 px、em、rem 值）的条件下，可以用上 margin-left 负值。子元素不定宽的时候用 <code>transform: translateX(-50%)</code> 可以解决问题。</p>
<p>绝对定位的原理也可以应用到垂直居中上。</p>
<h4 id="inline-block-text-align"><a href="#inline-block-text-align" class="headerlink" title="inline-block + text-align"></a>inline-block + text-align</h4><p>inline-block：对外呈现行内元素，对内呈现块级元素。所以可以设定宽高；没有指定宽高的时候，像行内元素一样由内容去界定盒子大小。可以像行内元素一样，多个排列在一行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个 inline-block 元素并排，元素之间在某些情况下会出现“莫名的间隙”。</p>
<p><img src="inline-block-gap.png" alt="inline-block gap"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不会有间隙 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child box"</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child box"</span>&gt;</span>ff<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 出现间隙 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child box"</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child box"</span>&gt;</span>ff<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>间隙是子元素之间的空格符或回车符引起的。既然是字符，那便可以让它“最小化”，达到去除间隙的目的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单行文字、图片、块框垂直居中"><a href="#单行文字、图片、块框垂直居中" class="headerlink" title="单行文字、图片、块框垂直居中"></a>单行文字、图片、块框垂直居中</h4><p>居中单行文字，只需给文字所在的元素加上 line-height 属性，值等于元素 height 。</p>
<p>单行图片也是类似的，我们把图片看成文字。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"child"</span> <span class="attr">src</span>=<span class="string">"xxx.jpg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vertical-align 属性只对 table-cell 以及 inline-element 起作用。如果垂直居中一个块框，把它的 display 属性设为 inline-block，然后处理方法如图片垂直居中。</p>
<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>指定包含框为一个 flex 容器，定义项目在主轴和次轴的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="经典布局方案"><a href="#经典布局方案" class="headerlink" title="经典布局方案"></a>经典布局方案</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>布局的思路参考 Matthew Levine 于2006年在「A LIST APART」上写的文章 <a href="https://alistapart.com/article/holygrail" target="_blank" rel="noopener">In Search of the Holy Grail
</a> 。侧边栏定宽，中间自适应布局，用 padding 空出容器两边的侧边栏，通过浮动定位放置三栏。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>#header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>#footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://alistapart.com/d/holygrail/diagram_01.gif" alt=""></p>
<p><a href="https://codepen.io/sheepig-the-bashful/full/MPWPwP" target="_blank" rel="noopener">codepen demo</a></p>
<p>主要的技巧是 <code>margin-left: -100%</code> 会导致浮动块上移一行，盖住前一块。margin-left 负的值等于浮动块 width 时，上移一行，紧贴前一个块的末尾。</p>
<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>当页面缩放，中间块的 content 宽度小于任一侧边栏的时候，会发生布局混乱。</p>
<p><img src="https://camo.githubusercontent.com/5dcd3ed2efcb76a372a2d0db44e7b993192d5cdc/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f31312f31332f31356662346564623132616261316134" alt=""></p>
<p>因为 padding 不会被计算到包含块里面，三栏都是浮动的，就会造成“挤不下”的局面。</p>
<p><a href="https://codepen.io/sheepig-the-bashful/full/YJPqVW" target="_blank" rel="noopener">codepen demo</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>#header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle-wrap column"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>#footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>container 不需要设置 padding ，直接让它撑满视口。我们在中间那一栏加了一层 div ，同样让它撑满父元素。</p>
<p>左右两栏的 margin 相对于包含块 container 的 content 宽度计算的，因为 container 没有内边距，所以这两栏上移的时候会移到 middle-wrap 的外边距里面。</p>
]]></content>
      <categories>
        <category>css 基础</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css 选择器优先级计算</title>
    <url>/2018/11/20/css-selector/</url>
    <content><![CDATA[<h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><blockquote>
<p>主要内容：<br>css 选择器优先级，一些优化。</p>
</blockquote>
<h3 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h3><h4 id="样式规则来源"><a href="#样式规则来源" class="headerlink" title="样式规则来源"></a>样式规则来源</h4><ul>
<li>外部样式表或样式元素中的 CSS 规则</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p &#123;<span class="attr">color</span>:blue&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inline 样式属性及类似内容</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p style=<span class="string">"color:blue"</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>HTML 可视化属性（映射到相关的样式规则）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p bgcolor=<span class="string">"blue"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="样式表层叠顺序（优先级从低到高）"><a href="#样式表层叠顺序（优先级从低到高）" class="headerlink" title="样式表层叠顺序（优先级从低到高）"></a>样式表层叠顺序（优先级从低到高）</h4><ol>
<li>浏览器声明</li>
<li>用户普通声明</li>
<li>作者普通声明</li>
<li>作者重要声明</li>
<li>用户重要声明</li>
</ol>
<h4 id="CSS-特异性"><a href="#CSS-特异性" class="headerlink" title="CSS 特异性"></a>CSS 特异性</h4><p>一个（或一组）选择器规则的优先级计算。用四个数字表示 <code>a-b-c-d</code> 。</p>
<ul>
<li>如果声明来自于 <code>style</code> 属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li>
<li>计算选择器中 ID 属性（ID attributes，例 <code>#example</code> ）的个数 (= b)</li>
<li>计算选择器中其他属性（other attributes，包括属性选择器 attributes selectors， 例 <code>[type=&quot;radio&quot;]</code> ；类选择器 class selector ，例 <code>.example</code>）和伪类（pseudo-classes，例 <code>:hover</code>）的个数 (= c)</li>
<li>计算选择器中元素名称（element name，例 <code>h1</code>）和伪元素（pseudo-elements，例 <code>::before</code>）的个数 (= d)</li>
</ul>
<p>粗略看，优先级（从高到低）大致如下：</p>
<ol>
<li>!important</li>
<li>style</li>
<li>id 选择器</li>
<li>类选择器（<code>.clas</code>），属性选择器（<code>[type=&quot;radio&quot;]</code>），伪类选择器（<code>:hover</code>）</li>
<li>类型选择器（<code>h1</code>），伪元素（<code>::before</code>）</li>
</ol>
<p>多组选择器组合，可以计算其最终优先级 <code>a-b-c-d</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">*             &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></span><br><span class="line">li            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></span><br><span class="line">li:first-line &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line">ul li         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line">ul ol+li      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></span><br><span class="line">h1 + *[rel=up]&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></span><br><span class="line">ul ol li.red  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></span><br><span class="line">li.red.level  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></span><br><span class="line">#x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span><br><span class="line">style=<span class="string">""</span>          <span class="comment">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span></span><br></pre></td></tr></table></figure>
<p>比如，有以下规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">    background: #333;</span><br><span class="line">    font-size: <span class="number">30</span>px;</span><br><span class="line">&#125;</span><br><span class="line">ul li &#123;</span><br><span class="line">    background: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ul li</code> 的特异性要优先于 <code>li</code> ，所以冲突的属性 <code>background</code> 由 <code>ul li</code> 定义。最终页面的 li 元素的 <code>background</code> 值为 <code>#ccc</code> ，<code>font-size</code> 值为 <code>30px</code> 。</p>
<h3 id="样式书写顺序"><a href="#样式书写顺序" class="headerlink" title="样式书写顺序"></a>样式书写顺序</h3><p>规范的书写顺序更易于后期的维护。常见书写顺序有这几种：</p>
<ul>
<li>按首字母排序</li>
<li>按 <code>property: value</code> 长度</li>
<li>按 <code>Outside In</code> 规则【推荐】</li>
</ul>
<h4 id="Outside-In"><a href="#Outside-In" class="headerlink" title="Outside In"></a>Outside In</h4><p>按一个 CSS 属性对它周边的元素和自身的影响程度，由大到小排序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SASS INHERITANCE */</span></span><br><span class="line">@extend</span><br><span class="line">@mixin, e.g. clearfix</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GENERATED CONTENT */</span></span><br><span class="line">content</span><br><span class="line"></span><br><span class="line"><span class="comment">/* POSITION AND LAYOUT */</span></span><br><span class="line">position</span><br><span class="line">z-index</span><br><span class="line">top</span><br><span class="line">bottom</span><br><span class="line">left</span><br><span class="line">right</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flexbox properties */</span></span><br><span class="line">float</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DISPLAY AND VISIBILITY */</span></span><br><span class="line">display</span><br><span class="line">opacity</span><br><span class="line">transform</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLIPPING */</span></span><br><span class="line">overflow</span><br><span class="line">clip</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ANIMATION */</span></span><br><span class="line">animation</span><br><span class="line">transition</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BOX MODEL (FROM OUTSIDE IN) */</span></span><br><span class="line">margin</span><br><span class="line">box-shadow</span><br><span class="line">border</span><br><span class="line">border-radius</span><br><span class="line">box-sizing</span><br><span class="line">width</span><br><span class="line">height</span><br><span class="line">padding</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BACKGROUND */</span></span><br><span class="line">background</span><br><span class="line">cursor</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TYPOGRAPHY */</span></span><br><span class="line">font-size</span><br><span class="line">line-height</span><br><span class="line">font-family</span><br><span class="line">font-weight</span><br><span class="line">font-style</span><br><span class="line">text-align</span><br><span class="line">text-transform</span><br><span class="line">word-spacing</span><br><span class="line">color</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PSEUDO-CLASSES &amp; PSEUDO-ELEMENTS (NESTED RULES) */</span></span><br><span class="line">:hover</span><br><span class="line">:focus</span><br><span class="line">:active</span><br><span class="line">:before</span><br><span class="line">:after</span><br><span class="line">:first-child</span><br><span class="line">:last-child</span><br></pre></td></tr></table></figure>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><p>伪类和伪元素的优先级，跟类和元素的优先级映射是一样的。伪类 &gt; 伪元素。</p>
<p><a href="https://www.w3.org/TR/CSS2/selector.html#pseudo-elements" target="_blank" rel="noopener">css2.1 selector 章节</a>说明了为什么引入伪类和伪元素。</p>
<blockquote>
<p>CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree.</p>
</blockquote>
<p>意思就是，引入伪类和伪元素的目的，是格式化文档树以外的信息。</p>
<p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。关于伪元素使用场景，可以看<a href="https://www.yinchengli.com/2016/10/30/using-before-after/" target="_blank" rel="noopener">Effective前端4：尽可能地使用伪元素</a></p>
<blockquote>
<p>参考</p>
<p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#CSS_parsing" target="_blank" rel="noopener">浏览器工作原理 CSS解析</a></p>
<p><a href="https://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="noopener">Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a></p>
<p><a href="https://9elements.com/css-rule-order/" target="_blank" rel="noopener">HOW TO ORGANIZE CSS @ 9ELEMENTS</a></p>
<p><a href="https://www.yinchengli.com/2016/10/30/using-before-after/" target="_blank" rel="noopener">Effective前端4：尽可能地使用伪元素</a></p>
<p><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">AlloyTeam——总结伪类与伪元素</a></p>
</blockquote>
]]></content>
      <categories>
        <category>css 基础</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>debounce 防抖</title>
    <url>/2018/11/20/debounce/</url>
    <content><![CDATA[<p>函数去抖背后的基本思想是指，某些代码不可以在没有间断的情况连续重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。<br>比如连续滚动。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">method, wait, context</span>) </span>&#123;</span><br><span class="line">    clearTimeout(method.tId);</span><br><span class="line">    method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        method.call(context);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对<code>scroll</code>事件测试：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'scroll'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure></p>
<p>连续滚动（每次间隔时间小于1000ms，不会触发<code>handle</code>方法，因为每次触发都会取消上一次的延时事件，然后重新设置延时1000ms。只有两次<code>scroll</code>事件间隔超过1000ms，前一次的才会被触发。</p>
<h3 id="debounce更加常规的写法：返回一个闭包"><a href="#debounce更加常规的写法：返回一个闭包" class="headerlink" title="debounce更加常规的写法：返回一个闭包"></a>debounce更加常规的写法：返回一个闭包</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">method, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'debounce initialized'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 清空上一次定时器</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            method.apply(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = debounce(handle,<span class="number">1000</span>);</span><br><span class="line">box.addEventListener(<span class="string">'scroll'</span>,fun);</span><br></pre></td></tr></table></figure></p>
<p>脚本加载后，<code>debounce initialized</code>只会被打印一次。<code>box</code>的<code>scroll</code>事件的触发有1000ms防抖。</p>
<p>:point_right: <a href="https://jsfiddle.net/xqy_young/Ls2jaxvp/3/?utm_source=website&amp;utm_medium=embed&amp;utm_campaign=Ls2jaxvp" target="_blank" rel="noopener">demo in jsfiddle</a></p>
]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2018/11/20/currying/</url>
    <content><![CDATA[<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>实现 <code>add(2)(3)(4)...(n)</code> 。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// 闭包存储args</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'===== args ====='</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn_args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// 合并参数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'===== fn_args ====='</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(fn_args);</span><br><span class="line">        <span class="keyword">return</span> add.apply(<span class="literal">null</span>, args.concat(fn_args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fn valueOf called'</span>);</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span>  a + b );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><img src="img1.png" alt="chained-calls"></p>
<p>试打印 <code>n</code> 的值，注意浏览器中 <code>console.log</code> 会尝试将n转换成字符串输出。此时有隐式转换发生。注意这个时候 <code>n</code> 是一个 <code>Function</code> 类型。</p>
<p><img src="img2.png" alt=""></p>
<blockquote>
<p><code>valueOf</code> 和 <code>toString</code> 方法：在特定的情况下，这俩个方法都会自动调用，而且在用户定义了新的 <code>valueOf</code> 和 <code>toString</code> 的时候，会优先执行新的方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Babel 转译结果看 ES6</title>
    <url>/2018/11/20/es6-syntax-sugar/</url>
    <content><![CDATA[<h2 id="ES6-gt-ES5"><a href="#ES6-gt-ES5" class="headerlink" title="ES6 =&gt; ES5"></a>ES6 =&gt; ES5</h2><p>转义结果来自babel</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context)&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Component);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过 class 定义的“类”，不能像 <code>Component(p, c)</code> 这样创建一个对象。通过 <code>this</code> 向对象添加熟悉，和传统构造函数基本一样。</p>
<p>如果有自定义的函数呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props, context)&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">  	<span class="keyword">this</span>.context = context;</span><br><span class="line">  &#125;</span><br><span class="line">  fn() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">      descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">      descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">    <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">    <span class="keyword">return</span> Constructor;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123; <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Component = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, Component);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Component, [&#123;</span><br><span class="line">    key: <span class="string">'fn'</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Component;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>Component 变成了一个自执行匿名函数。在这个函数里面，创建一个同名的构造函数 <code>Component</code> ，最后返回它。属性的创建方法同前一个例子一样，方法则是通过 <code>_createClass</code> 方法创建。</p>
<p>我们把 <code>Component</code> 构造函数和一个携带 <code>fn</code> 信息的对象数组传给了 <code>_createClass</code> 自执行函数（闭包），最后的结果就是通过 <code>Object.defineProperty</code> ，把函数（们）挂在了 <code>Component</code> 的原型对象（<code>Component.prototype</code>）上。class 声明的“类”中的函数，是挂在原型对象上的，由所有实例共享。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Component();</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Component();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1.fn === c2.fn); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="class-extends…"><a href="#class-extends…" class="headerlink" title="class extends…"></a>class extends…</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">  &#125;</span><br><span class="line">  fn() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123; <span class="keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>; descriptor.configurable = <span class="literal">true</span>; <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>; <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor); &#125; &#125; <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123; <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps); <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps); <span class="keyword">return</span> Constructor; &#125;; &#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123; <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123; <span class="keyword">if</span> (!self) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>); &#125; <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>) ? call : self; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function, not "</span> + <span class="keyword">typeof</span> superClass); </span><br><span class="line">  &#125; </span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line">    <span class="keyword">constructor</span>: &#123; </span><br><span class="line">      value: subClass, </span><br><span class="line">      enumerable: <span class="literal">false</span>, </span><br><span class="line">      writable: <span class="literal">true</span>, </span><br><span class="line">      configurable: <span class="literal">true</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); </span><br><span class="line">  <span class="keyword">if</span> (superClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> App = <span class="function"><span class="keyword">function</span> (<span class="params">_Component</span>) </span>&#123;</span><br><span class="line">  _inherits(App, _Component);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, App);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _this = _possibleConstructorReturn(<span class="keyword">this</span>, (App.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(App)).call(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    _this.props = props;</span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(App, [&#123;</span><br><span class="line">    key: <span class="string">'fn'</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> App;</span><br><span class="line">&#125;(Component);</span><br></pre></td></tr></table></figure>
<p><code>App</code> 是一个自执行函数，父类 <code>Component</code> 作为参数被传入。 <code>_inherits</code> 方法，子类 <code>subClass.prototype</code> 继承 <code>superClass.prototype</code> 。App 构造函数处理继承父类属性，最后返回 App 构造函数。</p>
<h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>rest 参数使得我们可以传入多余参数，把他们当数组一样处理。（实际上在内部，他们的确被转化成一个数组）。这样就可以不用 arguments 参数。arguments 参数是类数组对象，除了 length 属性和索引元素之外没有任何 Array 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, items = <span class="built_in">Array</span>(_len &gt; <span class="number">1</span> ? _len - <span class="number">1</span> : <span class="number">0</span>), _key = <span class="number">1</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">    items[_key - <span class="number">1</span>] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>js-prototype-pollution</title>
    <url>/2019/07/21/js-prototype-pollution/</url>
    <content><![CDATA[<blockquote>
<p>长草的 github 某一天突然往邮箱狂发了几个 vulnerable dependency 的提醒，才知 lodash 爆漏洞了。该漏洞是个原型污染问题，由开源安全平台 Snyk 的开发者 Liran Tal发现，详情看[这里]。</p>
</blockquote>
<h3 id="lodash-漏洞"><a href="#lodash-漏洞" class="headerlink" title="lodash 漏洞"></a>lodash 漏洞</h3><p>lodash 有个 defaultsDeep 方法，也就是默认的深拷贝方法，它能够实现这样的功能：</p>
<blockquote>
<p>分配来源对象（该方法的第二个参数）的可枚举属性到目标对象（该方法的第一个参数）所有解析为 undefined 的属性上</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.defaultsDeep(&#123; <span class="string">'a'</span>: &#123; <span class="string">'b'</span>: <span class="number">2</span> &#125; &#125;, &#123; <span class="string">'a'</span>: &#123; <span class="string">'b'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="string">'a'</span>: &#123; <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>在第二个参数上动些手脚，可以修改对象原型链上的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeFn = <span class="built_in">require</span>(<span class="string">'lodash'</span>).defaultsDeep;</span><br><span class="line"><span class="keyword">const</span> payload = <span class="string">'&#123;"constructor": &#123;"prototype": &#123;"a0": true&#125;&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mergeFn(&#123;&#125;, <span class="built_in">JSON</span>.parse(payload));</span><br><span class="line">    <span class="keyword">if</span> ((&#123;&#125;)[<span class="string">`a0`</span>] === <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Vulnerable to Prototype Pollution via <span class="subst">$&#123;payload&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">check();</span><br></pre></td></tr></table></figure>
<p>这里在空对象 <code>{}</code> 上加了一个 <code>a0</code> 熟悉。既然能增加，那么修改也不是问题了，如果修改 <code>toString</code> 原型方法，例如把 <code>payload</code> 换成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> payload = <span class="string">'&#123;"constructor": &#123;"prototype": &#123;"toString": true&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure>
<p>那么 <code>Object.prototype.toString</code> 就很不安全了。</p>
<p>lodash 紧急发布的修复中，对第二个拷贝参数作了键值判断</p>
<p><img src="https://res.cloudinary.com/snyk/image/upload/v1562272212/Screen_Shot_2019-07-04_at_23.29.28.png" alt=""></p>
<p><img src="https://res.cloudinary.com/snyk/image/upload/v1562272212/Screen_Shot_2019-07-04_at_23.29.28.png" alt=""></p>
<h3 id="NodeJS-漏洞案例"><a href="#NodeJS-漏洞案例" class="headerlink" title="NodeJS 漏洞案例"></a>NodeJS 漏洞案例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === <span class="built_in">Object</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;</span><br><span class="line">            merge(a[attr], b[attr]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[attr] = b[attr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"><span class="keyword">const</span> admin = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"> </span><br><span class="line">app.use(<span class="string">'/'</span>, express.static(path.join(__dirname, <span class="string">'views'</span>)));</span><br><span class="line">app.post(<span class="string">'/signup'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(req.body));</span><br><span class="line">    <span class="keyword">var</span> copybody = clone(body)</span><br><span class="line">    <span class="keyword">if</span> (copybody.name) &#123;</span><br><span class="line">        res.cookie(<span class="string">'name'</span>, copybody.name).json(&#123;</span><br><span class="line">            <span class="string">"done"</span>: <span class="string">"cookie set"</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="string">"error"</span>: <span class="string">"cookie not set"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/getFlag'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> аdmin = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(req.cookies))</span><br><span class="line">    <span class="keyword">if</span> (admin.аdmin == <span class="number">1</span>) &#123;</span><br><span class="line">        res.send(<span class="string">"hackim19&#123;&#125;"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.send(<span class="string">"You are not authorized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p>问题出在 <code>merge</code> 函数上，攻击者可以通过以下方式绕过登陆验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -vv --header &apos;Content-type: application/json&apos; -d &apos;&#123;&quot;__proto__&quot;: &#123;&quot;admin&quot;: 1&#125;&#125;&apos; &apos;http://0.0.0.0:4000/signup&apos;; </span><br><span class="line"></span><br><span class="line">curl -vv &apos;http://0.0.0.0:4000/getFlag&apos;</span><br></pre></td></tr></table></figure>
<p>攻击案例来自：<a href="https://www.youtube.com/watch?v=LUsiFV3dsK8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=LUsiFV3dsK8</a></p>
<p>像接口数据的校验，就要小心原型被修改的可能。</p>
<h3 id="原型污染防范"><a href="#原型污染防范" class="headerlink" title="原型污染防范"></a>原型污染防范</h3><ul>
<li>使用 <code>Object.freeze()</code></li>
<li>使用 <code>Object.create(null)</code> </li>
</ul>
<blockquote>
<p>参考<br>(Snyk research team discovers severe prototype pollution security vulnerabilities affecting all versions of lodash)[<a href="https://snyk.io/blog/snyk-research-team-discovers-severe-prototype-pollution-security-vulnerabilities-affecting-all-versions-of-lodash/]" target="_blank" rel="noopener">https://snyk.io/blog/snyk-research-team-discovers-severe-prototype-pollution-security-vulnerabilities-affecting-all-versions-of-lodash/]</a></p>
<p>部分转载自<a href="https://juejin.im/post/5d271332f265da1b934e2d48#heading-2" target="_blank" rel="noopener">最新：Lodash 严重安全漏洞背后你不得不知道的 JavaScript 知识</a></p>
</blockquote>
]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>js 作用域相关问题</title>
    <url>/2018/11/20/js-scope-related/</url>
    <content><![CDATA[<h2 id="作用域、闭包相关问题集锦"><a href="#作用域、闭包相关问题集锦" class="headerlink" title="作用域、闭包相关问题集锦"></a>作用域、闭包相关问题集锦</h2><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">MDN IIFE（ 立即调用函数表达式）</a></p>
<p>判断以下执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> env = <span class="string">'outer'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(env);</span><br><span class="line">    <span class="keyword">var</span> env = <span class="string">'inner'</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> env = <span class="string">'outer'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> env = <span class="string">'inner'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(env); <span class="comment">// inner</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="扩展-console-log-方法"><a href="#扩展-console-log-方法" class="headerlink" title="扩展 console.log 方法"></a>扩展 console.log 方法</h3><p>扩展 console.log 方法，每个输出前增加一个自增序号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLog</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        id++;</span><br><span class="line">        <span class="keyword">var</span> fn_args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        fn_args.unshift(id+<span class="string">':'</span>);</span><br><span class="line">        fn.apply(<span class="literal">null</span>, fn_args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log = myLog(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foo'</span>);       <span class="comment">// 1: foo</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'bar'</span>);       <span class="comment">// 2: bar</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'num:'</span>, num); <span class="comment">// 3: num: 2</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>抓包详解 HTTPS 过程</title>
    <url>/2018/11/20/http-and-https/</url>
    <content><![CDATA[<h2 id="HTTPS-原理"><a href="#HTTPS-原理" class="headerlink" title="HTTPS 原理"></a>HTTPS 原理</h2><p>HTTPS = HTTP + S ，S 是 SSL 或 TLS 。</p>
<h3 id="SSL-amp-TLS"><a href="#SSL-amp-TLS" class="headerlink" title="SSL &amp; TLS"></a>SSL &amp; TLS</h3><p><img src="http://sean-images.qiniudn.com/tls-ssl-_tcp-ip_protocol.png" alt=""></p>
<ul>
<li><p><strong>SSL</strong>：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。<br>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
</li>
<li><p><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
</li>
</ul>
<h3 id="对称加密-amp-非对称加密"><a href="#对称加密-amp-非对称加密" class="headerlink" title="对称加密 &amp; 非对称加密"></a>对称加密 &amp; 非对称加密</h3><p>关于这两种加密方法，Medium 上有一篇文章 <a href="https://medium.freecodecamp.org/https-explained-with-carrier-pigeons-7029d2193351" target="_blank" rel="noopener">HTTPS explained with carrier pigeons</a> 用了通俗的方法，解释得挺清楚的。前端早读课也分享过<a href="https://mp.weixin.qq.com/s/GanPiEkJFJqURZ7HNUMXSQ" target="_blank" rel="noopener">翻译版</a></p>
<p>简单讲，对称加密（symmetric key cryptography），任一方都知道如何加密，如何解密。但是对称加密的前提是双方已经确认通信。如果要建立通信，不能把加密方法或密钥发送出去（可以被拦截，那加密就没什么意义了），也不能发送“加密”的密钥（对方不知道用什么方法解密）。所以接下来要解决的问题，就是怎么安全地把加密方法或密钥，发送给对方，避免中间人攻击（Man in the Middle Attack）。</p>
<p>非对称加密（ asymmetric key cryptography），一方可以加密信息，但是不能解密别人的已加密信息。比如 client 要向 server 发送一段 message ，大概过程如下：</p>
<p><img src="https.png" alt="asymmetric key cryptography"></p>
<p>这就是非对称加密的过程，加密方可以加密 message （lock the box），但是不能解密（open a locked box）。这里的 box 就是公钥（public key），打开 box 的 key 就是私钥（private key）</p>
<h3 id="可信任的-box"><a href="#可信任的-box" class="headerlink" title="可信任的 box"></a>可信任的 box</h3><p>上面这种方法还有一个问题，client 怎么确定，它接收到的 public key 是 server 发给它的。如果有一个中间人拦截了这个 public key ，替换成一个 evil key，再转发给 client。client 和 server 的对话安全，还是不可保证。</p>
<p>这时候需要一个第三方来告诉 client，刚刚接收到的 public key 是合法的。这就是 Certification Authority 机制。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/460263-60c696bb9f5f8715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="CA"></p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA 算法的核心：对一个大数进行因式分解极难。</p>
<h4 id="数学背景"><a href="#数学背景" class="headerlink" title="数学背景"></a>数学背景</h4><ol>
<li>欧拉函数</li>
</ol>
<blockquote>
<p>欧拉函数 φ(n) 是小于或等于 n 的正整数中与 n 互质的数的数目。</p>
</blockquote>
<p>例如 <code>φ(8) = 4</code> ，因为 1,3,5,7 均和 8 互质。</p>
<blockquote>
<p>如果p，q是质数，N = p * q，那么<br>$$φ(N) = φ(p)φ(q) = (p-1)(q-1)$$</p>
</blockquote>
<p>简单证明：</p>
<p>1) φ(1) = 1，小于等于 1 且于 1 互质的数只有 1 。</p>
<p>2) 如果 p 是质数，p &gt; 1，φ(p) = p - 1 。比如 5 是质数，那么 φ(5) = 4，因为 1,2,3,4 都与 5 互质。要证明这一点可以用反证法。从定义上，有 φ(p) ≤ p。</p>
<p>1° φ(p) ≠ p，因为 p 与 p 不互质，这样就剩下 p - 1 个数。</p>
<p>2° 假设剩下的 p - 1 中任取一个数 r ，r 与 p 不互质 。也就是存在最大公约数 s ，s ≠ 1 ，使得 ms = r, ns = p。</p>
<p>3° ns = p 与 p 是质数这一前提矛盾，假设不成立。</p>
<p>3) 若m,n互质，则 φ(mn) = φ(m)φ(n) 【证明未给出】</p>
<p>4) 如果n是a的k次幂，则 φ(n) = φ(a^k) = a^k - a^(k-1) = (a-1)a^(k-1) 【证明未给出】</p>
<ol start="2">
<li>模反元素</li>
</ol>
<blockquote>
<p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。<br>$$a * b = 1 mod(n)$$</p>
</blockquote>
<ol start="3">
<li>欧拉定理</li>
</ol>
<blockquote>
<p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：<br>$$a^φ(n) = 1(mod n)$$</p>
</blockquote>
<p>由此可得：a 的 φ(n - 1) 次方肯定是a关于n的模反元素。</p>
<p>欧拉定理就可以用来证明模反元素必然存在。</p>
<p>由模反元素的定义和欧拉定理我们知道，a 的 φ(n) 次方减去 1 ，可以被 n 整除。比如，3 和 5 互质，而 5 的欧拉函数 φ(5) 等于 4 ，所以 3 的 4 次方(81)减去 1 ，可以被 5 整除（80/5=16）。</p>
<p>小费马定理：</p>
<blockquote>
<p>假设正整数a与质数p互质，因为质数 p 的 φ(p) 等于 p - 1，则欧拉定理可以写成<br>a^(p-1) = 1 mod(p)<br>这其实是欧拉定理的一个特例。</p>
</blockquote>
<h4 id="公钥密钥生成"><a href="#公钥密钥生成" class="headerlink" title="公钥密钥生成"></a>公钥密钥生成</h4><ol>
<li>寻找两个不相等的大质数</li>
</ol>
<p>质数p，q，满足：</p>
<p>$$p ≠ q$$<br>$$N = p * q$$</p>
<ol start="2">
<li>根据欧拉函数获取 r</li>
</ol>
<p>$$r = φ(N) = φ(p)φ(q) = (p-1)(q-1)$$</p>
<ol start="3">
<li>选择一个小于 r 并与 r 互质的数 e，求得 e 关于 r 的模反元素，记为 d</li>
</ol>
<p>$$e * d = 1 mod(r)$$</p>
<p>e 通常取 65537 。</p>
<ol start="4">
<li>销毁 p 和 q</li>
</ol>
<p>公钥：(N, e)<br>私钥：(N, d)</p>
<p>N 和 e 会公开使用，所以“根据 N 和 e 破解出 d”的难度，决定了 RSA 的加密强度。</p>
<p>想解出 d ，d 是 e 关于 r 的模反元素，所以要解出 r 。</p>
<p>r = φ(N) = φ(p)φ(q) = (p-1)(q-1) ，所以需要解出 p ，q 。</p>
<p>N = p * q，从公开的数据中我们只知道 N 和 e ，所以问题的关键就是对 N 做因式分解能不能得出 p 和 q 。</p>
<h3 id="HTTPS-完整过程"><a href="#HTTPS-完整过程" class="headerlink" title="HTTPS 完整过程"></a>HTTPS 完整过程</h3><p>tcp 抓包结果如下：</p>
<p><img src="tcp.png" alt="tcp connection"></p>
<h4 id="建立-tcp-链接"><a href="#建立-tcp-链接" class="headerlink" title="建立 tcp 链接"></a>建立 tcp 链接</h4><p>前三段 tcp 报文，并且很明显有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C ---- [SYN]       Seq=0       ---&gt; S</span><br><span class="line">C &lt;--- [SYN] [ACK] Seq=0 Ack=1 ---- S</span><br><span class="line">C ----       [ACK] Seq=1 Ack=1 ---&gt; S</span><br></pre></td></tr></table></figure>
<p>这就是 tcp 三次握手。</p>
<h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><ul>
<li>TLS 版本</li>
</ul>
<p>使用的TLS版本是1.2，TLS有三个版本，1.0，1.1，1.2，1.2是最新的版本，https的加密就是靠的TLS安全传输层协议</p>
<p><img src="TSLversion.png" alt="TSL version"></p>
<ul>
<li>客户端当前的时间和一个随机密码串，这个时间是距Unix元年(1970.1.1)的秒数</li>
</ul>
<p><img src="random.png" alt="random"></p>
<ul>
<li>sessionId，会话ID，第一次连接时为0，如果有sessionId，则可以恢复会话，而不用重复握手过程</li>
</ul>
<p><img src="sessionID.png" alt="sessionID"></p>
<ul>
<li>浏览器支持的加密组合方式：可以看到，浏览器一共支持 17 种加密组合方式，发给服务器，让服务器选一个。</li>
</ul>
<p><img src="cipher-suites.png" alt="cipher-suites"></p>
<ul>
<li>server 域名</li>
</ul>
<p><img src="server-name.png" alt="server name"></p>
<p>域名是工作在应用层 http 里的，而握手是发生在 TLS ,还在传输层。在传输层里面就把域名信息告诉服务器，好让服务根据域名发送相应的证书。</p>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>服务器收到了Client Hello的信息后，就给浏览器发送了一个Server Hello的包，这个包里面有着跟Client Hello类似的消息</p>
<ul>
<li>时间、随机数等，注意服务器还发送了一个Session Id给浏览器</li>
</ul>
<p><img src="server-hello.png" alt="server hello"></p>
<ul>
<li>服务器选中的加密方式</li>
</ul>
<p><img src="cipher-suite.png" alt="cipher suite"></p>
<ul>
<li>Certificate 证书</li>
</ul>
<p><img src="certificate.png" alt="Certificate"></p>
<p>可以看到 server 发送了两份证书</p>
<p><img src="ca.png" alt="CA"></p>
<p>在浏览器中可以查看这些证书的关系。</p>
<p><img src="ca-detail.png" alt="ca detail"></p>
<p>GlobalSign Root CA 是系统根证书，现代网络操作系统都会内置一份可信的根证书列表（Firefox 的根证书列表独立于操作系统之外）。<br>所谓“可信的根证书列表”是指操作系统开发商通过严格地审核，将安全可靠、可被信任的 CA 机构纳入白名单，并将这些权威可信 CA 的根证书预安装到操作系统中。</p>
<p>浏览器中可以查看根证书</p>
<p><img src="root-ca.png" alt="root ca"></p>
<p><code>*.juejin.im</code> 的证书是依赖于 <code>GlobalSign Domain</code> 的证书，换句话说，<code>GlobalSign Domain</code> 的证书为 <code>*.juejin.im</code> 的证书做担保，而根证书 <code>GlobalSign Root</code> 为 <code>GlobalSign Domain</code> 做担保，形成一条依赖链。明白这点很重要，从技术的角度上来说，<code>GlobalSign</code> 为 <code>*.juejin.im</code> 的证书做签名，只要签名验证正确就说明 <code>*.juejin.im</code> 的证书是合法的。</p>
<p><code>*.juejin.im</code> 证书里面会指明它的上一级证书</p>
<p><img src="ca-relation.png" alt="ca relation"></p>
<p>现在来看下一个证书里面具体有什么内容。</p>
<p>除了上面提到的签名外，每个证书还包含签名的算法，和被签名的证书 tbsCertificate(to be signed Certificate)三部分：</p>
<p><img src="signed-ca.png" alt="signed ca"></p>
<p>tbsCertificate 展开可以看到证书所支持的域名、有效期</p>
<p><img src="support-domain.png" alt="supported domain"></p>
<p><img src="validity.png" alt="validity"></p>
<p>还有证书的公钥</p>
<p><img src="pubkey.png" alt="pubkey"></p>
<p>把公钥拷贝出来，是一个 270 字节的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String publicKey = <span class="string">"3082010a0282010100a33da1f26ef4586d7b5da8be5cfbe5b48b8cd2d00df6960b640fab2d959a2cac1ae4022756c1f70d2701de0b133039c29793cf0c21382e18f1d6720f1d57c0261ee07a0afeb508e83896e1ce3e98d9ccc636e2b1627be11b258b6e5c1cc8c4721dbf2c6672cc8e2c23da576b6ecbf3f93227e756a7b195f00e329d043e1ba84af1a259e69c06a80a050d1b5649e6e52a93c4d418f43361282883591ae90019ea933054799c330d046fde030260dc815bee0b292b5c2317b6eff77e2d37512101c0bde04b898aee85fb7ce73f93728ac8c506f785927073c2b18d7d479664bb95f2db970e984afdd0df70f6f7d1da3953672e804a1fd0354ddbf6063912dba9950203010001"</span>;</span><br></pre></td></tr></table></figure>
<p>黑色部分是标志位，公钥可以拆为 N 和 e 两部分。</p>
<p><img src="publicKey.png" alt="public key"></p>
<p>N 是一个十六进制的 512 位数字，换算成二进制有 2048 位。普通的证书是1024位，2048位是一个很高安全级别，换算成10进制是617位，如果你能够将这个617位的大整数拆成两个质数相乘，就可以推导出密钥（但这是不可能的）。</p>
<p>e 为 65537 ，证书通常取的幂指数都为这个数字。</p>
<p>证书里面可以知道证书的加密算法为RSA + SHA256，SHA是一种哈希算法，可用来检验证书是否被篡改过：</p>
<p><img src="encryptedCA.png" alt="encrypted CA"></p>
<p>将 encrypted 的值拷贝出来，就是证书的签名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String signature = <span class="string">"005bd43c64a8901c858bc8caf78c7eb75df6b71c11a51fff9afa1f1c8c1b7c4e12f70f1c02abaed13db0d791c105f620bf7b5d62f4cc29626acc941ba7088acad006c076be34afceb600107d3ebd997304d4d652143aba3161e5de12658bc3bec017cea58dec7993e678ef018f5d4709c5090db811f29da51baf28db97f04d6df2ef9893682128b0d3c74bf1c3531f474251cfcbb4a7c3832bec9c4e9719d58153f6547238f188c6f59af020b79d55a8722bdb64c5a0453be72a264d199fa6b35af72c88ff5cff7529f53d785afb1d343e782960af396f89201452c2725992d231e2277029eb12bcaaf4ccfd625fb0e2026bfc3946581690bb56ca6ca7864981"</span>;</span><br></pre></td></tr></table></figure>
<p>这个签名是一个 256 个字节的数字，它是 GlobalSign Domain 用它的密钥对 tbsCertificate 做的签名，可以用 GlobalSign Domain 的公钥进行解密。</p>
<p>解出来的结果可以提取一段 SHA 哈希，记为 sha1，</p>
<p>对 tbsCertificate 做 SHA 哈希，得到 sha2，</p>
<p>只有 sha1 == sha2 ，我们认为证书没有被篡改。</p>
<p>中间人有没有可能既篡改了证书，还能保证哈希值是对的？首先不同的字符串被SHA256哈希后的值是一样的概率比较小，同时由于密钥和公钥是一一配对的，（签名是用证书的私钥加密的，可以用证书的公钥解密它。但是没有这个必要，因为最后要用私钥再把它加密回去，而我们拿不到私钥）所以中间人只能把公钥改成它的公钥，这个公钥是一个p * q 的整数，所以他必须得满足两个条件，一个是要更改成一个有意义的公钥，另一个是整个证书的内容被哈希后的值和没改前是一样的，满足这两个条件就相当困难了。</p>
<h4 id="Server-Key-Exchange-和-Client-Key-Exchange"><a href="#Server-Key-Exchange-和-Client-Key-Exchange" class="headerlink" title="Server Key Exchange 和 Client Key Exchange"></a>Server Key Exchange 和 Client Key Exchange</h4><p>看抓包结果，Server Key Exchange 和 Certificate 是在同一段报文里面的。</p>
<p>客户端确认证书合法之后，接收 server 的公钥，并把自己的公钥发送给 server 。</p>
<p>这次交换的公钥，要比证书的公钥短很多，只有 97 字节。同时加密的算法也不是 RSA （RSA的计算量太大）所以RSA是用来验证身份然后交换密钥的，并不是用来加密数据的，因为它计算量太大。加密数据是用的ECDHE生成的密钥和公钥。</p>
<p><img src="public-key-length.png" alt="public key length"></p>
<p>同样地，浏览器结合服务器发给它的随机密码(Server Hello)，生成它自己的主密钥，然后发送公钥发给服务器</p>
<p>双方交换密钥之后，浏览器给服务器发了一个明文的 Change Cipher Spec 的包，告诉服务器我已经准备好了，可以开始传输数据了,同样地，服务器也会给浏览器发一个Change Cipher Spec的包：</p>
<p><img src="change-ciper-spec.png" alt="change ciper spec"></p>
<p>实际上，这些包并不是一个个单独发的，client 发送 Client Key Exchange 的时候，连带把 Change Cipher Spec 的包和 Encrypted Handshake Message 的请求一并发送出去，server 的响应也是类似的。这样可以节约几次 RTT 时间。</p>
<p>浏览器给服务回了个ACK，然后就开始传输数据：</p>
<p>数据传输过程，是对称加密的，那为什么还要交换公钥？公钥的作用是加密“对称加密的钥匙”。</p>
<p>服务器选择的数据传输加密方式为AES，AES是一种高效的加密方式，它会使用主密钥（服务器的私钥）生成另外一把密钥。</p>
<blockquote>
<p>参考</p>
<p><a href="https://segmentfault.com/a/1190000002554673#articleHeader0" target="_blank" rel="noopener">SSL/TLS原理详解</a></p>
<p><a href="https://juejin.im/post/5a76d7e3f265da4e752770a3" target="_blank" rel="noopener">RSA 算法详解</a></p>
<p><a href="https://fed.renren.com/2017/02/03/https/" target="_blank" rel="noopener">https连接的前几毫秒发生了什么</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>css line-height &amp; vertical-align</title>
    <url>/2019/01/05/line-height/</url>
    <content><![CDATA[<p>写样式到时候经常遇到单行文字垂直居中，对于高度已知的块级元素，我们知道一种简单写法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">line-height</span>: 30<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 30<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p>设定行高，到底改变了什么？</p>
<h3 id="字体的度量"><a href="#字体的度量" class="headerlink" title="字体的度量"></a>字体的度量</h3><p>先从英文字母开始。刚开始学ABCD的时候，我们都知道练习本上面有四条线。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Typography_Line_Terms.svg/410px-Typography_Line_Terms.svg.png" alt=""></p>
<p>我们知道一些字母，比如小写的 a、e，是完全写在中间两条线之间的。写大写字母的时候，比如 A，B，它们的最顶部不会顶到第一条线，那样就很难看了——老师一般是这么说的，但是实际上，AB这样的大写字母，本身就不“顶天”。</p>
<p>这里我们先明确两个概念：</p>
<ul>
<li><code>Capital Height</code> 大写字母高度</li>
<li><code>x-height</code> 字母 x 的高度</li>
</ul>
<p>字体的高度和具体字符的高度不是一个概念，英文练习本上面，英文字符大多有上下留白。</p>
<p>现在又有一个问题，字体的高度是怎么算的？我们平时用 px 去设定 font-size ，对不同字体的结果一样吗？</p>
<hr>
<p>传统金属字块，我们可以看到一个字符是摆在一个方格里面的。同种字体，所有字符的方格是一样的，不同字体的区别在于方格的大小，以及字符在方格中上下“留白”大小。</p>
<p><img src="https://designwithfontforge.com/en-US/images/MetalTypeZoomIn.JPG" alt=""></p>
<p>我们来看字体的度量</p>
<ul>
<li><p>字体定义其 <a href="https://designwithfontforge.com/en-US/The_EM_Square.html" target="_blank" rel="noopener">em square</a>，也称为 “em size” 或 “UPM” ，是字符所处的容器。对于 OpenType 字体，这个值通常是 1000 ；对于 TrueType 字体，这个值是 2 的指数，通常设定为 1024 或 2048 。</p>
</li>
<li><p>字体块对外高度由 ascender、descender 和 line gap决定。</p>
</li>
<li>具体字符由 capital height、x-height 决定</li>
</ul>
<p>以 Arial 字体为例，以下是它的参数。</p>
<p><img src="font.jpg" alt=""></p>
<p>设定 <code>font-size: 100px</code> ，<code>&lt;p&gt;&lt;/p&gt;</code>块最终高度是多少？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>skdjdAfd<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="outcome.png" alt=""></p>
<p>结果是 115px ，也就是说 Arial 字体 line-height normal 值为 1.15。计算为 <code>(ascent + descent + line gap)/em-square</code> ，line gap（线间距）不是所有字体都有。</p>
<p>ascent+descent区域，我们称为内容区域（content-area）</p>
<p>没有人为设定字体行高的时候，content-area + line-gap（有些字体为 0 ） 为 line-height。</p>
<p>到这里可以确定，开篇提到的那种居中方法，居中的其实是 content-area 。</p>
<h3 id="line-box"><a href="#line-box" class="headerlink" title="line-box"></a>line-box</h3><p>当 <code>&lt;p&gt;</code> 元素呈现在屏幕上，它根据它的宽度可以有很多线。每一行是由一个或多个行内元素（HTML标签元素或匿名内联元素文本内容）组成，专业术语称为行盒（line-box）。line-box的高度是基于它的子元素高度的。浏览器为每个行内元素计算的高度都是line-box（子元素的最高点到最低点）。因此line-box的总高度足以包含所有子元素（默认情况下）。</p>
<h3 id="line-height-的值"><a href="#line-height-的值" class="headerlink" title="line-height 的值"></a>line-height 的值</h3><p>line-height normal 的值，依据不同字体去计算，如果是数字或百分比，相对字体的大小计算。改变 line-height 可能是一件危险的事，所有字体都有自己的安全行高，如果 line-height 过小，字符可能超出 line-box 。</p>
<p><img src="chop.jpg" alt=""></p>
<blockquote>
<p>参考<br><a href="https://www.w3cplus.com/css/css-font-metrics-line-height-and-vertical-align.html" target="_blank" rel="noopener">深入了解CSS字体度量，行高和vertical-align</a></p>
</blockquote>
]]></content>
      <categories>
        <category>css 基础</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>实现promise</title>
    <url>/2020/07/16/promise-implement/</url>
    <content><![CDATA[<p>网上关于如何实现promise的文章可以说是满天飞了，之前也<a href="https://www.xqyoung.com/2018/11/20/promise-lie/#Promise-A">翻译过Promise A+规范</a>。今天的文章主要是实现一个简易版的promise，其中的接口按照Promise A+规范来，在手写代码过程中，发现Promise A+规范的对变量乃至函数接口的命名，是非常恰当的。</p>
<h2 id="初级版"><a href="#初级版" class="headerlink" title="初级版"></a>初级版</h2><p>这一步只实现3个东西：Promise对象、then方法、还有一个叫Promise Resolution Procedure的东西。</p>
<p>其实规范只规定了这三个东西，前两者好理解。后者Promise Resolution Procedure意思？用人话解释就是：then方法返回一个Promise对象p2，那么调用then方法的p1的状态和最终值，将由p2的状态和最终值决定。（这里不考虑thenable对象）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><p>都0202年了，用下 class 吧：）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>._status = PENDING;</span><br><span class="line">        <span class="keyword">this</span>._result = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/** promise 成功/失败后，注册的then应该是按照顺序执行的，这里用两个队列维护 */</span></span><br><span class="line">        <span class="keyword">this</span>._onResolveQueue = [];</span><br><span class="line">        <span class="keyword">this</span>._onRejectQueue = [];</span><br><span class="line">        <span class="comment">/** 传入的fn其实是个函数</span></span><br><span class="line"><span class="comment">         * new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment">         *   console.log(1)</span></span><br><span class="line"><span class="comment">         *   resolve(3)</span></span><br><span class="line"><span class="comment">         * &#125;)</span></span><br><span class="line"><span class="comment">         * 我们希望fn立刻执行，resolve的值保留到给到promise</span></span><br><span class="line"><span class="comment">         * 那么就是在fn执行的时候绑定到promise实例上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *resolve 和 reject方法类似，以resolve为例，在Promise(fn) 调用resolve的时候，将值作为promise的最终值，并清空回调队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resolve(res) &#123;</span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">        <span class="keyword">this</span>._result = res;</span><br><span class="line">        <span class="comment">// 清空queue</span></span><br><span class="line">        <span class="keyword">this</span>.emptyQueue(<span class="keyword">this</span>._onResolveQueue)</span><br><span class="line">    &#125;</span><br><span class="line">    reject(err) &#123;</span><br><span class="line">        <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">        <span class="keyword">this</span>._result = err;</span><br><span class="line">        <span class="keyword">this</span>.emptyQueue(<span class="keyword">this</span>._onRejectQueue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * then方法注册的回调函数应该是异步执行的。这里简单用setTimeout包装下</span></span><br><span class="line"><span class="comment">     * 更多实现可以看nextTick：https://www.xqyoung.com/2018/11/20/promise-lie/#nextTick-%E5%AE%9E%E7%8E%B0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    emptyQueue(queue) &#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            queue.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(_this._result));</span><br><span class="line">            queue.length = <span class="number">0</span>;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * then 方法接受两个参数，onResolve，onReject</span></span><br><span class="line"><span class="comment"> * 以p.then(...)为例子</span></span><br><span class="line"><span class="comment"> * 如果p成功则onResolve的方法要加入_onResolveQueue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function">(<span class="params">onResolve, onReject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 onResolve, onReject 不是函数，忽略，同时实现透传，即</span></span><br><span class="line">  <span class="comment">// Promise.then().then(num =&gt; &#123;console.log(num);&#125;)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onResolve !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>._status === FULFILLED ||</span><br><span class="line">    <span class="keyword">typeof</span> onReject !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>._status === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// then 方法返回一个promise</span></span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// return 的Promise命名为p2吧</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 回调函数也可能执行失败 需要try-catch 包装下</span></span><br><span class="line">        <span class="comment">// p的状态由p2决定</span></span><br><span class="line">        <span class="keyword">const</span> successCb = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resolve(onResolve(result))</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                reject(onReject(result))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> failCb = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reject(onReject(err))</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                reject(onReject(e))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调函数入队</span></span><br><span class="line">        onResolve &amp;&amp; that._status !== REJECTED &amp;&amp; that._onResolveQueue.push(successCb);</span><br><span class="line">        onReject &amp;&amp; that._status !== FULFILLED &amp;&amp; that._onRejectQueue.push(failCb);</span><br><span class="line">        <span class="comment">// p已经FULFILLED/REJECTED</span></span><br><span class="line">        <span class="comment">// 清空对应回调函数队列</span></span><br><span class="line">        that._status === FULFILLED &amp;&amp; that.emptyQueue(that._onResolveQueue);</span><br><span class="line">        that._status === REJECTED &amp;&amp; that.emptyQueue(that._onRejectQueue);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充下静态方法"><a href="#补充下静态方法" class="headerlink" title="补充下静态方法"></a>补充下静态方法</h2><p>Promise.resolve 等方法，基于then方法封装下就好了。</p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>{
    <span class="keyword">static</span> resolve(any) {
        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {
            resolve(any);
        })
    }
    <span class="keyword">static</span> reject(any) {
        <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params"><span class="literal">undefined</span>, reject</span>) =&gt;</span> {
            reject(any)
        })
    }
}

MyPromise.prototype.catch = <span class="function">(<span class="params">onReject</span>) =&gt;</span> {
    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onReject)
}
</code></pre>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>解析 Lie 库 Promise 源码</title>
    <url>/2018/11/20/promise-lie/</url>
    <content><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h3><p>以下内容译自 Promise/A+ 规范。</p>
<p>Promise 代表一个异步操作的最终结果。操作一个 promise 的主要方式是通过它的 <code>then</code> 方法，该方法接收一个回调，回调参数是 promise 的最终值或这个 promise 转为 fulfilled 失败的原因。</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul>
<li>“promies” 是一个对象或函数，并有一个符合规范的 <code>then</code> 方法</li>
<li>“thenable” 是一个定义 <code>then</code> 方法的对象或函数</li>
<li>“value” 是任何合法的 JavaScript 值（包括 <code>undefined</code> ，一个 thenable ，或一个 promise）</li>
<li>“exception” 是用 <code>throw</code> 声明抛出的值</li>
<li>“reason” 指明一个 promise 为什么被 rejected 。</li>
</ul>
<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><h5 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h5><p>一个 promise 只能处于三种状态中的一种：<code>pending</code>, <code>fulfilled</code> 或 <code>rejected</code> 。</p>
<p>当 promise 处于 pending 时：</p>
<ul>
<li>可能转换为 fulfilled、 rejected 之一</li>
</ul>
<p>当 promise 处于 fulfilled 时：</p>
<ul>
<li>不可转换为其他状态</li>
<li>必须有一不可更改的 value</li>
</ul>
<p>当 promise 处于 rejected 时：</p>
<ul>
<li>不可转换为其他状态</li>
<li>必须有一个不可更改的 reason</li>
</ul>
<p>这里所说的“不可更改”，指的是自身不变性（比如 <code>===</code> ），但不需要遵循深层不可变性。</p>
<hr>
<h5 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a><code>then</code> 方法</h5><p>promise 必须提供一个 <code>then</code> 方法，用以访问当前的/最终的 value 或 reason 。</p>
<p><code>then</code> 方法接收两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, OnRejected)</span><br></pre></td></tr></table></figure>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数</p>
<ul>
<li>如果 <code>onFulfilled</code> 不是函数，忽略</li>
<li>如果 <code>onRejected</code> 不是函数，忽略</li>
</ul>
<p>如果 <code>onFulfulled</code> 是函数</p>
<ul>
<li>它必须在 <code>promise</code> 转换为 fulfilled 之后调用，第一个参数是 <code>promise</code> 的 value</li>
<li>不可以在 <code>promise</code> 转换为 fulfilled 之前调用</li>
<li>不可以被调用一次以上</li>
</ul>
<p>如果 <code>onRejected</code> 是函数</p>
<ul>
<li>它必须在 <code>promise</code> 转换为 rejected 之后调用，第一个参数是 <code>promise</code> 的 reason</li>
<li>不可以在 <code>promise</code> 转换为 rejected 之前调用</li>
<li>不可以被调用一次以上</li>
</ul>
<p>当且仅的<a href="https://es5.github.io/#x10.3" target="_blank" rel="noopener">执行上下文</a>栈只包含<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">平台代码</a> <code>onFulfilled</code> 和 <code>onRejected</code> 被调用</p>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 必须以函数的形式调用（不能有 <code>this</code> ，严格模式下 <code>this</code> 为 <code>undefined</code> ，非严格模式下 <code>this</code> 指向 <code>global</code> 对象）。</p>
<p><code>then</code> 可能在同个 promise 上多次调用</p>
<ul>
<li>如果/当 promise 转换为 fulfilled ，所有对应的 <code>onFulfilled</code> 回调会按照 <code>then</code> 发起的顺序调用。</li>
<li>如果/当 promise 转换为 rejected ，所有对应的 <code>onRejected</code> 回调会按照 <code>then</code> 发起的顺序调用。</li>
</ul>
<p><code>then</code> 必须返回一个 promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>onFulfilled</code> 或 <code>onRejected</code> 之一返回一个 value ，则执行 Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code> </li>
<li><code>onFulfilled</code> 或 <code>onRejected</code> 之一抛出一个异常 <code>e</code> ，<code>promise2</code> 必须被 rejected ，并且将  <code>e</code> 作为 reason 传入</li>
<li>如果 <code>onFulfilled</code> 不是一个函数而且 <code>promise1</code> 转换为 fulfilled ，<code>promise2</code> 必须转换为 fulfilled ，并且将 <code>promise1</code> 的 value 传入。</li>
<li>如果 <code>onRejected</code> 不是一个函数而且 <code>promise1</code> 转换为 rejected ，<code>promise2</code> 必须转换为 rejected ，并且将 <code>promise1</code> 的 reason 传入。</li>
</ul>
<hr>
<h5 id="Promise-Resolution-Procedure"><a href="#Promise-Resolution-Procedure" class="headerlink" title="Promise Resolution Procedure"></a>Promise Resolution Procedure</h5><p><strong>Promise Resolution Procedure</strong> 是一个抽象的操作，输入是一个 promise 和一个 value ， 我们用 <code>[[Resolve]](promise, x)</code> 表示，如果 <code>x</code> 是 thenable 的，它做此尝试：在 <code>x</code> 表现得像一个 promise 的前提下，让  <code>promise</code> 采用 <code>x</code> 的状态( <code>state</code> )。否则将 <code>promise</code> 的状态转换为 fulfilled ，<code>x</code> 作为 value 。</p>
<p>执行 <code>[[Resolve]](promise, x)</code> ，会执行以下步骤：</p>
<p>如果 <code>promise</code> 和 <code>x</code> 指向同个对象，以一个 <code>TypeError</code> 为 reason ，拒绝这个 <code>promise</code> 。</p>
<ol>
<li><p>如果 <code>x</code> 是一个 promise ，采用它的 state</p>
<ul>
<li>如果 <code>x</code> 处于 pending 中，<code>promise</code> 必须保持 pending 直至 <code>x</code> 转换为 fulfilled 或 rejected </li>
<li>如果/当 <code>x</code> 转换为 fulfilled ，以相同的 value ，履行这个 <code>promise</code> （fulfill <code>promise</code> with the same value）</li>
<li>如果/当 <code>x</code> 转换为 rejected ，以相同的 reason ，拒绝这个 <code>promise</code> （reject <code>promise</code> with the same reason）</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>如果 x 是一个对象或者函数</p>
<ul>
<li>令 <code>then</code> = <code>x.then</code></li>
<li>如果访问 <code>x.then</code> 会抛出一个异常 <code>e</code> ，以 <code>e</code> 为 reason 拒绝这个 promise </li>
<li>如果 then 是一个函数，将它的 <code>this</code> 绑定为 <code>x</code> 并调用它，第一个参数是 <code>resolvePromise</code> ，第二个参数是 <code>rejectedPromise</code> 。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then.call(x, resolvePromise, rejectedPromise)</span><br></pre></td></tr></table></figure>
<p>如果 <code>resolvePromise</code> 调用，调用返回值是 <code>y</code> ，执行 <code>[[Resolve]](promise, y)</code></p>
<p>如果 <code>rejectedPromise</code> 调用，调用返回值是 <code>r</code> ，以 <code>r</code> 为由拒绝 <code>promise</code> </p>
<p>如果 <code>resolvePromise</code> <code>rejectedPromise</code> 都被调用，或者以相同参数多次调用，则只采用第一次调用，忽略其他调用</p>
<p>如果调用 then 抛出一个异常 e ：</p>
<p>如果 <code>resolvePromise</code> <code>rejectedPromise</code> 都已经被调用，忽略 e </p>
<p>否则，以 <code>e</code> 为 reason 拒绝这个 <code>promise</code> </p>
<ul>
<li>如果 <code>then</code> 不是一个函数，以 <code>x</code> 履行这个 <code>promise</code> （fulfill promise with x）</li>
</ul>
<ol start="3">
<li>如果 x 既不是函数也不是对象，以 <code>x</code> 履行这个 <code>promise</code> （fulfill promise with x）</li>
</ol>
<h3 id="解析-lie-库的-Promise-实现"><a href="#解析-lie-库的-Promise-实现" class="headerlink" title="解析 lie 库的 Promise 实现"></a>解析 lie 库的 Promise 实现</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>Promise 任何实例 promise （接下来用 promise 指代 Promise 实例）在一个时刻，只能是三种状态之一：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REJECTED = [<span class="string">'REJECTED'</span>];</span><br><span class="line"><span class="keyword">var</span> FULFILLED = [<span class="string">'FULFILLED'</span>];</span><br><span class="line"><span class="keyword">var</span> PENDING = [<span class="string">'PENDING'</span>];</span><br></pre></td></tr></table></figure>
<h4 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">	resolve(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果是 1234 。入参的匿名函数似乎是立刻执行的（ 1，2 最先被打印），但是 resolve 之后没有立刻 then ，而是先执行完所有同步代码（打印 3 ），再去调用一个回调（打印 4 ）。</p>
<p>看一下 Promise 的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> resolver !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'resolver must be a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="keyword">this</span>.queue = [];</span><br><span class="line">  <span class="keyword">this</span>.outcome = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (resolver !== INTERNAL) &#123;</span><br><span class="line">    safelyResolveThenable(<span class="keyword">this</span>, resolver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新创建的 promise 的状态，会被初始化为 PENDING 。入参 resolver 就是 <code>function(resolve, reject) { // ... }</code> 这样的一个函数，看一下 <code>safelyResolveThenable(this, resolver)</code> 做了什么。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safelyResolveThenable</span>(<span class="params">self, thenable</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Either fulfill, reject or reject with error</span></span><br><span class="line">  <span class="keyword">var</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    handlers.reject(self, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onSuccess</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    handlers.resolve(self, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tryToUnwrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    thenable(onSuccess, onError);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = tryCatch(tryToUnwrap);</span><br><span class="line">  <span class="keyword">if</span> (result.status === <span class="string">'error'</span>) &#123;</span><br><span class="line">    onError(result.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 thenable 就是传进来的 resolver 。可以看到 thenable 被调用：<code>var result = tryCatch(tryToUnwrap);</code> ，<br>tryCatch 其实是一个帮助函数，封装了 <code>func(value)</code> 的返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryCatch</span>(<span class="params">func, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> out = &#123;&#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    out.value = func(value);</span><br><span class="line">    out.status = <span class="string">'success'</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    out.status = <span class="string">'error'</span>;</span><br><span class="line">    out.value = e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thenable 执行环境中，以下三个语句按顺序执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">resolve(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>重点看一下 <code>resolve(4)</code> ，打断点，最终来到 handlers.resolve </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handlers.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">self, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = tryCatch(getThen, value);</span><br><span class="line">  <span class="keyword">if</span> (result.status === <span class="string">'error'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> handlers.reject(self, result.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> thenable = result.value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thenable) &#123;</span><br><span class="line">    safelyResolveThenable(self, thenable);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    self.state = FULFILLED;</span><br><span class="line">    self.outcome = value;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> len = self.queue.length;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">      self.queue[i].callFulfilled(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里 <code>self = p1</code> ，<code>value = 4</code> ，value 不是一个 thenable 类型（如果是 thenable 的处理？）。最后把 self 的 state 设为 FULFILLED ，把 outcome 赋值为 value ，返回 self 。</p>
<p>其实执行完 <code>resolve(4)</code> ，p1 的状态已经变为 FULFILLED ，并且有一个不可变的 value 。</p>
<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h4><p>then 方法的最主要作用，是访问一个 promise 最终的 value，或者 reason 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 onFulfilled, onRejected 不是函数，忽略，同时实现透传，即</span></span><br><span class="line">  <span class="comment">// Promise.then().then(num =&gt; &#123;console.log(num);&#125;)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === FULFILLED ||</span><br><span class="line">    <span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果是一个 promise ，为了和当前的 promise（即 this） 区分，命名为 promise2</span></span><br><span class="line">  <span class="keyword">var</span> promise2 = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(INTERNAL);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) &#123;</span><br><span class="line">  	<span class="comment">// 只有 promise 的 state 不是 PENDING 时，才会调用 onFulfilled 或者 onRejected</span></span><br><span class="line">  	<span class="comment">// 当状态为 FULFILLED 时，调用 onFulfilled ，并把 promise 的 value 传递给 onFulfilled</span></span><br><span class="line">  	<span class="comment">// 当状态为 REJECTED 时，调用 onRejected ，并把 promise 的 reason 传递给 onRejected</span></span><br><span class="line">    <span class="keyword">var</span> resolver = <span class="keyword">this</span>.state === FULFILLED ? onFulfilled : onRejected;</span><br><span class="line">    unwrap(promise2, resolver, <span class="keyword">this</span>.outcome);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	<span class="comment">// promise 的 state 为 PENDING ，把 promise2，onFulfilled 和 onRejected 包装成一个 QueueItem，</span></span><br><span class="line">  	<span class="comment">// 压入 promise 的 queue</span></span><br><span class="line">    <span class="keyword">this</span>.queue.push(<span class="keyword">new</span> QueueItem(promise2, onFulfilled, onRejected));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nextTick-实现"><a href="#nextTick-实现" class="headerlink" title="nextTick 实现"></a>nextTick 实现</h4><p>then 方法有链式传递，前一个 promise 的 value 或 reason 会传递给下一个 promise ， <code>promise.then(onFulfilled, onRejected)</code> ，真正在操作 value 和 reason 的其实是新的 promise（promise2）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrap</span>(<span class="params">promise, func, value</span>) </span>&#123;</span><br><span class="line">  immediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> returnValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 新的 promise 的状态是变为 FULFILLED 还是 REJECTED，和它处理的是 value 还是 reason 没有必然联系，</span></span><br><span class="line">      <span class="comment">// 也就是说它的状态转换不受前一个 promise 的状态影响，它只根据前一个 promise 提供的 value/reason，分别调用自己不同的处理方法</span></span><br><span class="line">      <span class="comment">// 如果处理成功，比如成功处理前一个 promise 传过来的 reason ，那么新的 promise 会被 resolve</span></span><br><span class="line">      <span class="comment">// 否则 reject</span></span><br><span class="line">      returnValue = func(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> handlers.reject(promise, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (returnValue === promise) &#123;</span><br><span class="line">      handlers.reject(promise, <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Cannot resolve promise with itself'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handlers.resolve(promise, returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>immediate</code> 注册一个异步方法，使得：当且仅当执行上下文只有平台代码的时候，执行 then 的回调 onFulfilled 或 onRejected 。类似 setTimeout 0 ，但又不仅仅如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immediate</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (queue.push(task) === <span class="number">1</span> &amp;&amp; !draining) &#123;</span><br><span class="line">    scheduleDrain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>queue</code> <code>draining</code> 是闭包中可以访问的变量。queue 用以保存回调，以便按序执行，draining 标记当前是否有回调执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> draining;</span><br><span class="line"><span class="keyword">var</span> queue = [];</span><br></pre></td></tr></table></figure>
<p>只有在当前仅有一个任务 task ，并且之前的任务已经全部执行完毕（draining === false），才会调用 <code>scheduleDrain()</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Mutation = global.MutationObserver || global.WebKitMutationObserver;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 浏览器环境 IE11+ 支持，使用 MutationObserver</span></span><br><span class="line">  <span class="keyword">if</span> (Mutation) &#123;</span><br><span class="line">    <span class="keyword">var</span> called = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> Mutation(nextTick);</span><br><span class="line">    <span class="keyword">var</span> element = global.document.createTextNode(<span class="string">''</span>);</span><br><span class="line">    observer.observe(element, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      element.data = (called = ++called % <span class="number">2</span>); <span class="comment">// called 的值在 0/1 之间切换</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// Node.js 环境，使用 MessageChannel</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!global.setImmediate &amp;&amp; <span class="keyword">typeof</span> global.MessageChannel !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> channel = <span class="keyword">new</span> global.MessageChannel();</span><br><span class="line">    channel.port1.onmessage = nextTick;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      channel.port2.postMessage(<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// 低版本浏览器，使用一个 script 标签，当它插入文档中，它的 readystatechange 事件会触发</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'document'</span> <span class="keyword">in</span> global &amp;&amp; <span class="string">'onreadystatechange'</span> <span class="keyword">in</span> global.document.createElement(<span class="string">'script'</span>)) &#123;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a &lt;script&gt; element; its readystatechange event will be fired asynchronously once it is inserted</span></span><br><span class="line">      <span class="comment">// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.</span></span><br><span class="line">      <span class="keyword">var</span> scriptEl = global.document.createElement(<span class="string">'script'</span>);</span><br><span class="line">      scriptEl.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        nextTick();</span><br><span class="line"></span><br><span class="line">        scriptEl.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">        scriptEl.parentNode.removeChild(scriptEl);</span><br><span class="line">        scriptEl = <span class="literal">null</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      global.document.documentElement.appendChild(scriptEl);</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">// 最后什么都不行，用 setTimeout 0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleDrain = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(nextTick, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduleDrain 的根本目的，是尽可能较快，异步触发 nextTick 。以下是几种方案：</p>
<p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> 监控一个空文本节点，每次调用 scheduleDrain 之后会把 called 的值从 0 改为 1（或从 1 改回 0）。改变这个 DOM 节点会触发<br><code>new Mutation(nextTick)</code> 注册的回调。这种回调的执行顺序会比 setTimeout 快。</p>
<p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener">MessageChannel</a>，port1 的 message 事件触发时候，调用 nextTick 回调。scheduleDrain 执行时，通过 <code>port2.postMessage</code> 触发 port1 的 message 事件。</p>
<p>低版本浏览器用一个动态插入的 script 标签，它的 readystatechange 事件会触发，触发的结果就是立即执行 nextTick 。这种“事件触发调用 nextTick” 的思想和前面两种方法很接近，但是用 script 标签要注意，在 readystatechange 事件最后要移除 script 标签。</p>
<p>最后，如果以上三种方案都不支持，用 setTimeout 0 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  draining = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> i, oldQueue;</span><br><span class="line">  <span class="keyword">var</span> len = queue.length;</span><br><span class="line">  <span class="keyword">while</span> (len) &#123;</span><br><span class="line">    oldQueue = queue;</span><br><span class="line">    queue = [];</span><br><span class="line">    i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">      oldQueue[i]();</span><br><span class="line">    &#125;</span><br><span class="line">    len = queue.length;</span><br><span class="line">  &#125;</span><br><span class="line">  draining = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nextTick 按 queue 中 回调的顺序，逐个执行回调，执行完之后把 draining 重置为 false 。</p>
<p>看一下这段代码的执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">	resolve(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then( <span class="function"><span class="params">num</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(num); &#125;);</span><br><span class="line">&#125;).then().then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>结果是 1234 。细节如下：</p>
<ol>
<li><p>Promise 的入参是同步执行的，所以先打印 1 。</p>
</li>
<li><p>p1 先 resolve ，p1 状态 FULFILLED ，outcome = 4；</p>
</li>
<li><p>新建一个 Promise 实例，立刻把它的状态变为 RESOLVED ，注册 then 的成功回调。</p>
</li>
<li><p>注册 p1 的回调</p>
</li>
<li><p>执行同步代码</p>
</li>
<li><p>清空 queue 。</p>
</li>
</ol>
<h4 id="异步-resolver"><a href="#异步-resolver" class="headerlink" title="异步 resolver"></a>异步 resolver</h4><p>上面例子的中，调用 <code>resolve</code> 的时候是同步的，如果调用 <code>resolve</code> 是异步的，那么在 <code>then</code> 方法中，promise 的状态仍为 PENDING ，这时候 promise.queue 就派上用场了。</p>
<p><img src="resolver.png" alt=""></p>
<p>只是把异步 resolver 和 promise 的信息包装成一个 QueueItem ，压入 promise.queue 。</p>
<p>定时器结束后，promise 的状态才变成 RESOLVED ，此时才注册 then 回调。</p>
<p><img src="async-resolver.png" alt=""></p>
<h3 id="Promise-的其他接口"><a href="#Promise-的其他接口" class="headerlink" title="Promise 的其他接口"></a>Promise 的其他接口</h3><p>Promise A+ 其实没有规定 Promise 实现的其他接口。常用的 <code>promise.catch</code> <code>Promise.resolve</code> 其实都是基于 <code>then</code> 去扩展的。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype[<span class="string">"catch"</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以 <code>Promise.prototype.catch</code> 是 <code>this.then(null, onRejected)</code> 的别名。以下这两种写法本质是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'opps!'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h4><p>finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<p>finally 其实是 <code>then</code> 方法的特例，<code>onFulfilled</code> <code>onRejected</code> 的回调是同一个。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype[<span class="string">"finally"</span>] = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="comment">// finally 本质还是 then 方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">yes</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用 Promise.resolve 把一个新的 promise 转换成 RESOLVED，注册它的成功回调</span></span><br><span class="line">    <span class="comment">// 这里调用 callback 时，和 `this` 没有联系。callback 的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</span></span><br><span class="line">    <span class="keyword">return</span> p.resolve(callback()).then(yes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">no</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.resolve(callback()).then(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Promise-resolve-amp-amp-Promise-reject"><a href="#Promise-resolve-amp-amp-Promise-reject" class="headerlink" title="Promise.resolve &amp;&amp; Promise.reject"></a>Promise.resolve &amp;&amp; Promise.reject</h4><p>这两个方法比较接近，所以放在一块讲。Promise.resolve 多了一层判断，如果入参已经是一个 promise ，直接返回它。这两个方法本质都是新建一个 promise ，并且一定在未来某一时刻（可能是立刻），把它的状态转换为 FULFILLED 或 REJECTED 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = resolve;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handlers.resolve(<span class="keyword">new</span> <span class="keyword">this</span>(INTERNAL), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject = reject;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="keyword">this</span>(INTERNAL);</span><br><span class="line">  <span class="keyword">return</span> handlers.reject(promise, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里有必要重新看看 <code>handlers.resolve</code> 方法。<code>handlers.resolve(new this(INTERNAL), value)</code> 的 value 可以是一个 thenable 对象。即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.resolve(thenable).then((<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>这里 resolve 是同步的，promise 创建后，会调用 then 方法。</p>
<p>Promise.resolve 并不是总返回一个 resolved 对象。在 resolve 的时候其实用了 try catch 封装。catch 错误的时候会返回一个 rejected 的 promise 。</p>
<h4 id="Promise-all-amp-amp-Promise-race"><a href="#Promise-all-amp-amp-Promise-race" class="headerlink" title="Promise.all &amp;&amp; Promise.race"></a>Promise.all &amp;&amp; Promise.race</h4><p>Promise.all 返回的是一个 promise 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = all;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(iterable) !== <span class="string">'[object Array]'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'must be an array'</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = iterable.length;</span><br><span class="line">  <span class="keyword">var</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resolve([]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// values 数组，每个值是 iterable[i] resolve 的返回值。这个数组传递给 promise 的回调函数</span></span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">var</span> resolved = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// Promise.all 返回值是一个 promise</span></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="keyword">this</span>(INTERNAL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">    allResolver(iterable[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">allResolver</span>(<span class="params">value, i</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// n 次 Promise.resolve(iterable[i])</span></span><br><span class="line">    <span class="comment">// 第 i 次 Promise.resolve(iterable[i])，因为 iterable[i] resolve，把它的返回值赋给 values[i] </span></span><br><span class="line">    <span class="comment">// 等到所有 iterable[i] 都被 resolved ，也就是符合条件 ++resolved === len &amp;&amp; !called</span></span><br><span class="line">    <span class="comment">// 把 values 数组传递给 promise 回调</span></span><br><span class="line">    self.resolve(value).then(resolveFromAll, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">        <span class="comment">// 一旦有一个 iterable[i] 被rejected ，reject promise，并把 iterable[i] rejected 的 reason 传递过去</span></span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        handlers.reject(promise, error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 如果 iterable[i]</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolveFromAll</span>(<span class="params">outValue</span>) </span>&#123;</span><br><span class="line">      values[i] = outValue;</span><br><span class="line">      <span class="keyword">if</span> (++resolved === len &amp;&amp; !called) &#123;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        handlers.resolve(promise, values);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Promise.race 也会做 n 次 <code>Promise.resolve(iterable[i])</code> ，不同的是，第一个 <code>iterable[i]</code> 状态改变就会停止后面的 Promise.resolve ，并把 resolve/reject 结果传给 promise 。</p>
<blockquote>
<p>参考</p>
</blockquote>
<blockquote>
<p><a href="https://fed.renren.com/2018/03/10/promise/" target="_blank" rel="noopener">从一道Promise执行顺序的题目看Promise实现</a></p>
<p><a href="https://yuchengkai.cn/docs/zh/frontend/#promise-%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">InterviewMap-Promise 实现</a></p>
<p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener">详解JavaScript中的Event Loop（事件循环）机制</a></p>
</blockquote>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>throttle 节流</title>
    <url>/2018/11/20/throttle/</url>
    <content><![CDATA[<p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p>
<h3 id="时间戳方法"><a href="#时间戳方法" class="headerlink" title="时间戳方法"></a>时间戳方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间戳方法</span></span><br><span class="line"><span class="comment"> * @param   &#123;function&#125; method [节流的方法]</span></span><br><span class="line"><span class="comment"> * @param   &#123;number&#125;   delay  [间隔执行时间]</span></span><br><span class="line"><span class="comment"> * @returns &#123;function&#125;        []</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (now - prev &gt; delay) &#123;</span><br><span class="line">            method.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下用法<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = throttle(handle,<span class="number">1000</span>);</span><br><span class="line">box.addEventListener(<span class="string">'scroll'</span>,fun);</span><br></pre></td></tr></table></figure></p>
<p>时间戳方法，一般第一次<code>scroll</code>就会触发<code>method</code>。（除非脚本加载完1s内，<code>box</code>就触发了<code>scroll</code>事件。。。）最后一次<code>scroll</code>不会触发<code>method</code>（假设高频事件，最后两次事件挨着）:ghost:<a href="https://jsfiddle.net/xqy_young/Lzk9a7r4/" target="_blank" rel="noopener">demo online</a></p>
<h3 id="定时器方法"><a href="#定时器方法" class="headerlink" title="定时器方法"></a>定时器方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 定时器方法</span></span><br><span class="line"><span class="comment"> * @param   &#123;function&#125; method [节流的方法]</span></span><br><span class="line"><span class="comment"> * @param   &#123;number&#125;   delay  [间隔执行时间]</span></span><br><span class="line"><span class="comment"> * @returns &#123;function&#125;        []</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                method.apply(context, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用定时器之后，无论中间有没有中断<code>scroll</code>事件，每次的第一次触发都会延迟1000ms。当最后一次停止触发后，由于定时器的delay延迟，可能还会执行一次函数。<br>:ghost:<a href="https://jsfiddle.net/xqy_young/j698yg5z/" target="_blank" rel="noopener">demo online</a></p>
<h3 id="定时器-时间戳"><a href="#定时器-时间戳" class="headerlink" title="定时器+时间戳"></a>定时器+时间戳</h3><p>节流中用时间戳或定时器都是可以的。更精确地，可以用时间戳+定时器，当第一次触发事件时马上执行事件处理函数，最后一次触发事件后也还会执行一次事件处理函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时器+时间戳</span></span><br><span class="line"><span class="comment"> * @param   &#123;function&#125; method [节流的方法]</span></span><br><span class="line"><span class="comment"> * @param   &#123;number&#125;   delay  [间隔执行时间]</span></span><br><span class="line"><span class="comment"> * @returns &#123;function&#125;        []</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">var</span> remain = delay - (now - prev);</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            method.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                method.apply(context, args);</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>纯函数</title>
    <url>/2018/11/20/pure-function/</url>
    <content><![CDATA[<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><blockquote>
<p>参考<a href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide/ch03.html" target="_blank" rel="noopener">JS函数式编程-Pure Happiness with Pure Functions</a></p>
</blockquote>
<p>这里不探讨一些概念，直接看纯函数的应用。以下是来自原书的例子。</p>
<h3 id="小试身手"><a href="#小试身手" class="headerlink" title="小试身手"></a>小试身手</h3><h4 id="输入缓存"><a href="#输入缓存" class="headerlink" title="输入缓存"></a>输入缓存</h4><p>实现以下要求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">squareNumber(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//=&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>); <span class="comment">// 从缓存中读取输入值为 4 的结果</span></span><br><span class="line"><span class="comment">//=&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//=&gt; 25</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>); <span class="comment">// 从缓存中读取输入值为 5 的结果</span></span><br><span class="line"><span class="comment">//=&gt; 25</span></span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> memorize = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> argStr = <span class="built_in">JSON</span>.stringify(args);</span><br><span class="line">        cache[argStr] = cache[argStr] || fn(...args);</span><br><span class="line">        <span class="keyword">return</span> cache[argStr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squareNumber = memorize(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js 基础</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试题</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【译文】React 的多态性</title>
    <url>/2018/11/20/translation-react-polymorphism/</url>
    <content><![CDATA[<blockquote>
<p>原文链接 <a href="https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc" target="_blank" rel="noopener">Surprising polymorphism in React applications</a><br>如有不当，欢迎指正！</p>
</blockquote>
<h2 id="React-的多态性"><a href="#React-的多态性" class="headerlink" title="React 的多态性"></a>React 的多态性</h2><p>现今，基于 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 的 Web app 通常使用一些不可变的数据结构来管理状态，比如流行的 <a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a> 状态容器。 这种模式有几点好处，并且在 React/Redux 之外的领域愈加受欢迎。</p>
<p>这种机制的核心便是所谓的 <code>reducers</code>，它们是函数，根据触发的 <code>action</code> 更改某个状态到下一个状态————比如响应用户交互。有了这个核心的抽象概念，复杂的 <code>state</code> 和 <code>reducers</code> 可以组合成简化版本，方便了代码分段下的单元测试。请看下面来自于 <a href="http://redux.js.org/docs/basics/ExampleTodoList.html" target="_blank" rel="noopener">Redux 文档</a> 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redux-todo.js</span></span><br><span class="line"><span class="keyword">const</span> todo = <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        id: action.id,</span><br><span class="line">        text: action.text,</span><br><span class="line">        completed: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'TOGGLE_TODO'</span>:</span><br><span class="line">      <span class="keyword">if</span> (state.id !== action.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">        completed: !state.completed</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>todo</code> reducer 响应 <code>action</code> 将现存的 <code>state</code> 映射到一个新的 <code>state</code>。从性能优化的角度看代码，它似乎遵守了代码单态的原则，比如，保持对象的 <code>shape</code> 一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redux-todo-use.js</span></span><br><span class="line"><span class="keyword">const</span> s1 = todo(&#123;&#125;, &#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  text: <span class="string">"Finish blog post"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s2 = todo(s1, &#123;</span><br><span class="line">  type: <span class="string">'TOGGLE_TODO'</span>,</span><br><span class="line">  id: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> state.id + <span class="string">": "</span> + state.text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(s1);</span><br><span class="line">render(s2);</span><br><span class="line">render(s1);</span><br><span class="line">render(s2);</span><br></pre></td></tr></table></figure>
<p>坦白说，<code>render</code> 处理的属性应该是单态的，例如，<code>state</code> 对象的应当有一样的 <code>shape</code> —— <a href="https://github.com/v8/v8/wiki/Design%20Elements#fast-property-access" target="_blank" rel="noopener">map or hidden class in V8 speak</a>。在同一时刻，序列中的<code>s1</code> 和 <code>s2</code> 都有 <code>id</code> ，<code>test</code> ，<code>completed</code>  属性。然而，在 <code>d8</code> shell 上运行这段代码并追踪 ICs（inline cahces 内联缓存），我们观察到，<code>render</code> 侦测到不同的对象 shapes ，<code>state.id</code> 和 <code>state.test</code> 属性的访问是多态的。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*FrfEaOkxshIj79wJDQyrIQ.png" alt=""></p>
<p>那单态性从何说起？这其实很微妙，跟 V8 处理对象字面量的方式有关。每个对象字面量——比如，形如 <code>{a:va,...,z:vb}</code> 的表达式定义了 <code>transition</code> 树的根 <code>map</code> （记住 <code>map</code> 是 <code>V8 speak</code> 为 对象 <code>shape</code> 而生的）。如果你使用一个空的对象字面量 <code>{}</code> 作为 <code>transition</code> 树的跟，它就是不包含任何属性的 <code>map</code> ；如果使用 <code>{id:id, text:text, completed:completed}</code> 对象字面量，那么 <code>transition</code> 树的跟就是一个包含这些属性的 <code>map</code> 。看看一个简化的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transition-tree.js</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;;</span><br><span class="line">b.x = <span class="number">1</span>;</span><br><span class="line">b.y = <span class="number">2</span>;</span><br><span class="line">b.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a is"</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b is"</span>, b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a and b have same map:"</span>, %HaveSameMap(a, b));</span><br></pre></td></tr></table></figure>
<p>你可以在 Node.js 上运行这段代码，并附上 <code>--allow-natives-syntax</code> 命令行标识（允许使用内置的 <code>%HaveSameMap</code> ）:</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*yzSaH_AE5z7r9PWBXlvwWg.png" alt=""></p>
<p>尽管对象 <code>a</code> 和 <code>b</code> 看起来一样——拥有同样的属性，对应类型一样，顺序一样——它们的 map 却不同。这是因为它们有不同的 transition 树，如下图所示：</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*fkbEgBWk74icFH1yZIH7Lw.png" alt=""></p>
<p>使用不同的（不相容）的对象字面量创建对象时，多态性便隐藏在其中。这点在常用的 <code>Object.assign</code> 中尤为显著，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object-assign.js</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a is"</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b is"</span>, b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a and b have same map:"</span>, %HaveSameMap(a, b));</span><br></pre></td></tr></table></figure>
<p>仍是产生的了不同的 map ，因为对象 <code>b</code> 始于一个空的对象（<code>{}</code> 字面量），<code>Object.assign</code> 只是把属性一个个拼连上去。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*Xu-nIj21gj-GlHDkzsSOSA.png" alt=""></p>
<p>这同样适用于有大量属性并通过 Babel 编译的场景。因为 Babel——或者其他编译器——在对处理大量属性的时候使用了 <code>Object.assign</code> 。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*F2x8lRcZ83pQDvftelFOgA.png" alt=""></p>
<p>避免多态性的一种方式是从始至终使用 <code>Object.assign</code> 方法，那么所有的对象就始于一个空的对象字面量。但在状态管理逻辑中，这可能成为一个性能瓶颈。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// object-assign-everywhere.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a is"</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b is"</span>, b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a and b have same map:"</span>, %HaveSameMap(a, b));</span><br></pre></td></tr></table></figure>
<p>也就是说，关于代码多态化的问题还未停歇。保持单态性，对你的大多数代码来说，或许根本不重要。在无所谓的优化之前，你应当细心衡量对比。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>js底层</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】浅谈 Web Worker</title>
    <url>/2018/11/20/web-worker/</url>
    <content><![CDATA[<blockquote>
<p>转载自<a href="https://juejin.im/post/59c1b3645188250ea1502e46" target="_blank" rel="noopener">浅谈HTML5 Web Worker</a>，略有修改</p>
<p>参考<a href="https://www.html5rocks.com/zh/tutorials/workers/basics/" target="_blank" rel="noopener">Web Workers 的基本信息 HTML5 Rocks</a></p>
</blockquote>
<h2 id="浅谈-Web-Worker"><a href="#浅谈-Web-Worker" class="headerlink" title="浅谈 Web Worker"></a>浅谈 Web Worker</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">Web Worker</a> 使得一个 Web 应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。</p>
<p><a href="https://html.spec.whatwg.org/multipage/workers.html#workers" target="_blank" rel="noopener">规范</a>中介绍了两种 Worker ：专用 Worker 和 共用 Worker。本文只涉及专用 Worker，并在全文中将其称为“Web Worker”或“Worker”。</p>
<h3 id="创建-worker"><a href="#创建-worker" class="headerlink" title="创建 worker"></a>创建 worker</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">'task.js'</span>);</span><br><span class="line"></span><br><span class="line">myWorker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in main:'</span>, e.data)</span><br><span class="line">&#125;</span><br><span class="line">myWorker.postMessage(&#123;</span><br><span class="line">    msg: <span class="string">'from main'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>脚本 task.js 在 worker 线程运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">wait</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'in worker:'</span>, i);</span><br><span class="line">        postMessage(i);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 task.js 中，global 是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope" target="_blank" rel="noopener">DedicatedWorkerGlobalScope</a> 对象，setTimeout 时和最外部的 this 指向这个对象，所以这里没有指定调用 possMessage ，onmessage 的对象（其实就是 this.postMessage）。</p>
<p>创建 Worker 总需要新建一个脚本吗？不一定，可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL" target="_blank" rel="noopener">URL.createObjectURL()</a> 创建 URL 对象，实现内嵌 Worker</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> myTask = <span class="string">`</span></span><br><span class="line"><span class="string">    var i = 0;</span></span><br><span class="line"><span class="string">    function timedCount()&#123;</span></span><br><span class="line"><span class="string">        i = i+1;</span></span><br><span class="line"><span class="string">        postMessage(i);</span></span><br><span class="line"><span class="string">        setTimeout(timedCount, 1000);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    timedCount();</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([myTask]);</span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="built_in">window</span>.URL.createObjectURL(blob));</span><br></pre></td></tr></table></figure>
<h3 id="Worker-通信"><a href="#Worker-通信" class="headerlink" title="Worker 通信"></a>Worker 通信</h3><p>主页面与 Worker 之间的通信是通过 postMessage() 方法和 onmessage 事件。通信可以由任一方发起，另一方接收。</p>
<h4 id="简单数据传递"><a href="#简单数据传递" class="headerlink" title="简单数据传递"></a>简单数据传递</h4><p>在主页面与 Worker 之间传递的数据是通过拷贝，而不是共享来完成的。传递给 Worker 的对象需要经过序列化，接下来在另一端还需要反序列化。页面与 Worker 不会共享同一个实例，最终的结果就是在每次通信结束时生成了数据的一个副本。</p>
<p>也就是说，<strong>Worker 与其主页面之间只能单纯的传递数据，不能传递复杂的引用类型</strong>：如通过构造函数创建的对象等。并且，传递的数据也是经过拷贝生成的一个副本，在一端对数据进行修改不会影响另一端。</p>
<h4 id="通过可转让对象传递数据"><a href="#通过可转让对象传递数据" class="headerlink" title="通过可转让对象传递数据"></a>通过可转让对象传递数据</h4><p>前面介绍了简单数据的传递，其实还有一种性能更高的方法来传递数据，就是通过可转让对象将数据在主页面和Worker之间进行来回穿梭。可转让对象从一个上下文转移到另一个上下文而不会经过任何拷贝操作。这意味着当传递大数据时会获得极大的性能提升。和按照引用传递不同，一旦对象转让，那么它在原来上下文的那个版本将不复存在。该对象的所有权被转让到新的上下文内。例如，当你将一个 ArrayBuffer 对象从主应用转让到 Worker 中，原始的 ArrayBuffer 被清除并且无法使用。它包含的内容会(完整无差的)传递给 Worker 上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uInt8Array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">32</span>); <span class="comment">// 32MB</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uInt8Array .length; ++i) &#123;</span><br><span class="line">  uInt8Array[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uInt8Array.length); <span class="comment">// 传递前长度:33554432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myTask = <span class="string">`</span></span><br><span class="line"><span class="string">    onmessage = function (e) &#123;</span></span><br><span class="line"><span class="string">        var data = e.data;</span></span><br><span class="line"><span class="string">        console.log('worker:', data); // ArrayBuffer(33554432)</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([myTask]);</span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="built_in">window</span>.URL.createObjectURL(blob));</span><br><span class="line">myWorker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(uInt8Array.length); <span class="comment">// 传递后长度:0</span></span><br></pre></td></tr></table></figure>
<h3 id="importScripts"><a href="#importScripts" class="headerlink" title="importScripts()"></a>importScripts()</h3><p>Worker 线程能够访问一个全局函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope/importScripts" target="_blank" rel="noopener">improtScripts()</a> 来引入脚本，该函数接受 0 个或者多个 URI 作为参数。</p>
<p>此示例将 script1.js 和 script2.js 加载到了 Worker 中：</p>
<p>worker.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">'script1.js'</span>);</span><br><span class="line">importScripts(<span class="string">'script2.js'</span>);</span><br><span class="line"><span class="comment">// 可以访问 script1.js script2.js 中的全局变量</span></span><br></pre></td></tr></table></figure>
<p>也可以写成单个导入语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">importScripts(<span class="string">'script1.js'</span>, <span class="string">'script2.js'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="适用于-Worker-的功能"><a href="#适用于-Worker-的功能" class="headerlink" title="适用于 Worker 的功能"></a>适用于 Worker 的功能</h3><p>由于 Web Worker 的多线程行为，所以它们只能使用 JavaScript 功能的子集：</p>
<ul>
<li>navigator 对象</li>
<li>location 对象（只读）</li>
<li>XMLHttpRequest</li>
<li>setTimeout()/clearTimeout() 和 setInterval()/clearInterval()</li>
<li>应用缓存</li>
<li>使用 importScripts() 方法导入外部脚本</li>
<li>生成其他 Web Worker</li>
</ul>
<p>Worker 无法使用：</p>
<ul>
<li>DOM（非线程安全）</li>
<li>window 对象</li>
<li>document 对象</li>
<li>parent 对象</li>
</ul>
<h3 id="终止-terminate"><a href="#终止-terminate" class="headerlink" title="终止 terminate()"></a>终止 terminate()</h3><p>在主页面上调用 terminate() 方法，可以立即杀死 worker 线程，不会留下任何机会让它完成自己的操作或清理工作。另外，Worker 也可以调用自己的 close() 方法来关闭自己</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主页面调用</span></span><br><span class="line">myWorker.terminate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 线程调用</span></span><br><span class="line">self.close();</span><br></pre></td></tr></table></figure>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>当 worker 出现运行时错误时，它的 onerror 事件处理函数会被调用。它会收到一个实现了 ErrorEvent 接口名为 error 的事件。相关界面中包含用于找出错误内容的三个实用属性：filename - 导致错误的 Worker 脚本的名称；lineno - 出现错误的行号；以及 message - 有关错误的实用说明。</p>
<p>该事件不会冒泡，并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;output id=<span class="string">"error"</span> style=<span class="string">"color: red;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span></span><br><span class="line">&lt;output id=<span class="string">"result"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onError</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'error'</span>).textContent = [</span><br><span class="line">      <span class="string">'ERROR: Line '</span>, e.lineno, <span class="string">' in '</span>, e.filename, <span class="string">': '</span>, e.message].join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onMsg</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).textContent = e.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'workerWithError.js'</span>);</span><br><span class="line">  worker.addEventListener(<span class="string">'message'</span>, onMsg, <span class="literal">false</span>);</span><br><span class="line">  worker.addEventListener(<span class="string">'error'</span>, onError, <span class="literal">false</span>);</span><br><span class="line">  worker.postMessage(); <span class="comment">// Start worker without a message.</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例：workerWithError.js 尝试执行 1/x，其中 x 未定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workerWithError.js：</span></span><br><span class="line">self.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  postMessage(<span class="number">1</span>/x); <span class="comment">// Intentional error.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Worker-使用场景"><a href="#Worker-使用场景" class="headerlink" title="Worker 使用场景"></a>Worker 使用场景</h3><ul>
<li>预先抓取和/或缓存数据以便稍后使用</li>
<li>突出显示代码语法或其他实时文本格式</li>
<li>拼写检查程序</li>
<li>分析视频或音频数据</li>
<li>背景 I/O 或网络服务轮询</li>
<li>处理较大数组或超大 JSON 响应</li>
<li><code>&lt;canvas&gt;</code> 中的图片过滤</li>
<li>更新本地网络数据库中的多行内容</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>MDN 几个例子</p>
<p><a href="https://github.com/mdn/simple-web-worker" target="_blank" rel="noopener">基本的dedicated worker示例</a></p>
<p><a href="https://github.com/mdn/simple-shared-worker" target="_blank" rel="noopener">基本的 shared worker示例</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 WebSocket</title>
    <url>/2018/11/25/websocket-beginner/</url>
    <content><![CDATA[<p>WebSocket 是一种协议，<a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC 6455</a> 指出了它的目的：为基于浏览器的应用提供一种机制，使得应用可以在不依赖多条 HTTP 链接的情况（使用 XMLHttpRequest ，iframe 或长轮询）下与服务器进行通信。</p>
<h3 id="WebSocket-链接过程"><a href="#WebSocket-链接过程" class="headerlink" title="WebSocket 链接过程"></a>WebSocket 链接过程</h3><p>接下来用一个简单的例子，了解 WebSocket 链接的建立和通信过程。</p>
<p>Server 端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"> </span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> <span class="title">connection</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> <span class="title">incoming</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'received: %s'</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  ws.send(<span class="string">'something'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Client 端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection opened</span></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for messages</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Message from server '</span>, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>WebSocket 本质上还是基于 TCP 协议，所以 WebSocket client 和 server 通信的第一步，依然是建立 TCP 链接。这一点和 HTTP 协议的表现差不多。</p>
<h4 id="协议升级"><a href="#协议升级" class="headerlink" title="协议升级"></a>协议升级</h4><p>WebSocket 建立链接的握手过程，是要适配基于 HTTP 的服务端软件和中间件的，所以一个端口，可以同时允许一个 HTTP 客户端和一个服务器通信，或者一个 WebSocket 客户端和这个服务器通信。</p>
<p><img src="websocket-client.png" alt=""></p>
<p>TCP 建立后，客户端发起协议升级请求，下面是请求头部的部分信息。WebSocket 要求 HTTP 版本至少为 1.1 ，并且只支持 GET 请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET ws://localhost:8080/ HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http://localhost:3000</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: 8NgftYvA8Vyr7cGRS8WdpA==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure>
<ul>
<li>Upgrade 字段，值为 <code>websocket</code> ，表示要升级到 WebSocket 协议。</li>
<li>Sec-WebSocket-Version 字段，表示 WebSocket 的版本。如果服务端不支持该版本，需要返回一个 <code>Sec-WebSocket-Version</code> header ，里面包含服务端支持的版本号。</li>
<li>Sec-WebSocket-Key 字段，与后面服务端响应首部的 Sec-WebSocket-Accept 是配套的，用于告知客户端，服务器愿意初始化 WebSocket 链接。</li>
<li>Sec-WebSocket-Extensions 可选字段，表示协议级别上（可能为空）服务器可以使用的扩展。</li>
</ul>
<p>服务端同意协议升级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: JAz1fxUy5f9LbUgeVcToNl0yWzA=</span><br></pre></td></tr></table></figure>
<h4 id="Sec-WebSocket-Accept-的计算"><a href="#Sec-WebSocket-Accept-的计算" class="headerlink" title="Sec-WebSocket-Accept 的计算"></a>Sec-WebSocket-Accept 的计算</h4><ol>
<li>将客户端的 <code>Sec-WebSocket-Key</code> 跟 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 拼接。</li>
<li>计算拼接值的 SHA1 哈希值，转换为 Base64 编码。</li>
</ol>
<p><code>Sec-WebSocket-Key</code> 和 <code>Sec-WebSocket-Accept</code> 这一对配套的头部信息有什么用呢？<a href="https://tools.ietf.org/html/rfc6455#page-7" target="_blank" rel="noopener">RFC 6455</a> 是这样解释的：服务端要给客户端一个准信，它已经收到服务端的 WebSocket 握手请求了，针对这个客户端，服务端不接受非 WebSocket 链接，这样可以防止攻击者通过 XMLHttpRequest 或表单提交向 WebSocket 服务器发送伪装过的包。</p>
<h4 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h4><p>WebSocket 客户端、服务端通信的最小单位是帧（frame），由 1 个或多个帧组成一条完整的消息（message）。</p>
<p>发送端：将消息切割成多个帧，并发送给服务端；</p>
<p>接收端：接收消息帧，并将关联的帧重新组装成完整的消息；</p>
<h5 id="帧格式详解"><a href="#帧格式详解" class="headerlink" title="帧格式详解"></a>帧格式详解</h5><p>参考 <a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">RFC 6455 5.2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p><strong>FIN</strong> ，1 比特</p>
<p>指示这个帧是不是消息的最后一个分片（fragment）。1 表示是，0 表示否。</p>
<p><strong>RSV1，RSV2，RSV3</strong> ，3 比特</p>
<p>这个是跟 WebSocket 扩展有关的，全 0 表示没有使用任何扩展。</p>
<p><strong>Opcode</strong> ，4 比特</p>
<p>定义了对载荷数据（Payload Data）的解析。它有以下值：</p>
<ul>
<li><p><code>%x0</code> 表示一个延续帧，本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</p>
</li>
<li><p><code>%x1</code> 表示一个文本帧</p>
</li>
<li><p><code>%x2</code> 表示一个二进制帧</p>
</li>
<li><p><code>%x3-7</code> 预保留</p>
</li>
<li><p><code>%x8</code> 表示链接关闭</p>
</li>
<li><p><code>%x9</code> 表示一个 ping 操作</p>
</li>
<li><p><code>%xA</code> 表示一个 pong 操作</p>
</li>
<li><p><code>%xB-F</code> 预保留</p>
</li>
</ul>
<p><strong>Mask</strong> ，1 比特</p>
<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>
<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>
<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask 都是 1 。</p>
<p><strong>Payload length</strong>，7 比特，7+16 比特，或 7+64 比特</p>
<p>Payload data 的长度按字节计算，如果 Payload data 的长度为：</p>
<ul>
<li>0-125 字节，那么 Payload length 就是这个值</li>
<li>126 字节，后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度</li>
<li>127 字节，后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度</li>
</ul>
<p><strong>Masking-key</strong> 0 或 4 字节</p>
<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为 1，且携带了 4 字节的 Masking-key。如果 Mask 为 0 ，则没有 Masking-key 。</p>
<p>备注：载荷数据的长度，不包括mask key的长度。</p>
<p><strong>Payload data</strong> (x+y) 字节</p>
<p>包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>客户端和服务器建立 WebSocket 链接后，后续的操作都是基于数据帧。WebSocket 根据 <code>opcode</code> 来区分操作的类型。比如 0x8 表示断开连接，0x0-0x2 表示数据交互。</p>
<p>下面是<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" target="_blank" rel="noopener">MDN</a>的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文本帧，消息已经发送完毕，没有后续的帧</span><br><span class="line">Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</span><br><span class="line">Server: (process complete message immediately) Hi.</span><br><span class="line"></span><br><span class="line">// 文本帧，消息未发送完毕，还有后续的帧</span><br><span class="line">Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</span><br><span class="line">Server: (listening, new message containing text started)</span><br><span class="line">// 分片帧，消息未发送完毕，还有后续的帧，当前的数据帧需要接在上一条数据帧之后</span><br><span class="line">Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</span><br><span class="line">Server: (listening, payload concatenated to previous message)</span><br><span class="line">// 分片帧，消息发送完毕，没有后续的帧，当前的数据帧需要接在上一条数据帧之后</span><br><span class="line">Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</span><br><span class="line">Server: (process complete message) Happy new year to you too!</span><br></pre></td></tr></table></figure>
<h4 id="断开链接"><a href="#断开链接" class="headerlink" title="断开链接"></a>断开链接</h4><p>网络断开或页面关闭，会导致 WebSocket 关闭。如果通信双方长时间（默认 60 s）无数据交互，链接也会断开。断开的操作其实是 TCP 四挥手。</p>
<p>如果希望客户端和服务端保持稳定的链接，可以定时向对方发送心跳包。</p>
<ul>
<li>发送方-&gt;接收方：ping</li>
<li>接收方-&gt;发送方：pong</li>
</ul>
<p>ping、pong 的操作，对应的是 WebSocket 的两个控制帧，opcode 分别是 0x9、0xA 。</p>
<p>有个工具<a href="https://www.browsersync.io/" target="_blank" rel="noopener">browser-sync</a> 就用到 WebSocket ，它可以做到“一端更新，多端同步”的效果。其实就是在你开发的页面注入了一段脚本，在这个脚本里面启用了 WebSocket ，和本地服务通信。所以可以实现：浏览器-&gt;服务端-&gt;其他客户端 的刷新机制。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h4 id="掩码算法"><a href="#掩码算法" class="headerlink" title="掩码算法"></a>掩码算法</h4><p>ENCODED：原码</p>
<p>MASK：掩码键</p>
<p>掩码、反掩码都是采用以下算法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DECODED = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ENCODED.length; i++) &#123;</span><br><span class="line">    DECODED[i] = ENCODED[i] ^ MASK[i % <span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一下转载自<a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener">WebSocket协议：5分钟从入门到精通</a></p>
<p>WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。除了加密通道本身，似乎没有太多有效的保护通信安全的办法。</p>
<p>那么为什么还要引入掩码计算呢，除了增加计算机器的运算量外似乎并没有太多的收益。</p>
<p>答案还是两个字：安全。但并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p>
<p>在正式描述攻击步骤之前，我们假设有如下参与者：</p>
<ul>
<li>攻击者、攻击者自己控制的服务器（简称“邪恶服务器”）、攻击者伪造的资源（简称“邪恶资源”）</li>
<li>受害者、受害者想要访问的资源（简称“正义资源”）</li>
<li>受害者实际想要访问的服务器（简称“正义服务器”）</li>
<li>中间代理服务器</li>
</ul>
<p>攻击步骤一：</p>
<ol>
<li>攻击者浏览器 向 邪恶服务器 发起WebSocket连接。根据前文，首先是一个协议升级请求。<br>协议升级请求 实际到达 代理服务器。</li>
<li>代理服务器 将协议升级请求转发到 邪恶服务器。</li>
<li>邪恶服务器 同意连接，代理服务器 将响应转发给 攻击者。</li>
<li>由于 upgrade 的实现上有缺陷，代理服务器 以为之前转发的是普通的HTTP消息。因此，当协议服务器 同意连接，代理服务器 以为本次会话已经结束。</li>
</ol>
<p>攻击步骤二：</p>
<ol>
<li>攻击者 在之前建立的连接上，通过WebSocket的接口向 邪恶服务器 发送数据，且数据是精心构造的HTTP格式的文本。其中包含了 正义资源 的地址，以及一个伪造的host（指向正义服务器）。（见后面报文）</li>
<li>请求到达 代理服务器 。虽然复用了之前的TCP连接，但 代理服务器 以为是新的HTTP请求。</li>
<li>代理服务器 向 邪恶服务器 请求 邪恶资源。</li>
<li>邪恶服务器 返回 邪恶资源。代理服务器 缓存住 邪恶资源（url是对的，但host是 正义服务器 的地址）。</li>
</ol>
<p>到这里，受害者可以登场了：</p>
<ol>
<li>受害者 通过 代理服务器 访问 正义服务器 的 正义资源。</li>
<li>代理服务器 检查该资源的url、host，发现本地有一份缓存（伪造的）。</li>
<li>代理服务器 将 邪恶资源 返回给 受害者。</li>
<li>受害者 卒。</li>
</ol>
<p>附：前面提到的精心构造的“HTTP请求报文”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client → Server:</span><br><span class="line">POST /path/of/attackers/choice HTTP/1.1 Host: host-of-attackers-choice.com Sec-WebSocket-Key: &lt;connection-key&gt;</span><br><span class="line">Server → Client:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Sec-WebSocket-Accept: &lt;connection-key&gt;</span><br></pre></td></tr></table></figure>
<p>最初的提案是对数据进行加密处理。基于安全、效率的考虑，最终采用了折中的方案：对数据载荷进行掩码处理。</p>
<p>需要注意的是，这里只是限制了浏览器对数据载荷进行掩码处理，但是坏人完全可以实现自己的WebSocket客户端、服务端，不按规则来，攻击可以照常进行。</p>
<p>但是对浏览器加上这个限制后，可以大大增加攻击的难度，以及攻击的影响范围。如果没有这个限制，只需要在网上放个钓鱼网站骗人去访问，一下子就可以在短时间内展开大范围的攻击。</p>
<blockquote>
<p>参考<br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener">WebSocket协议：5分钟从入门到精通</a><br><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="noopener">RFC 6455</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 异步队列</title>
    <url>/2018/11/20/promise-async-then-chain/</url>
    <content><![CDATA[<blockquote>
<p>本文相关术语见 Promise A+ 规范<br><a href="https://www.xqyoung.com/2018/11/20/promise-lie/">解析 lie 库的 Promise</a></p>
</blockquote>
<h3 id="异步编程-Promise"><a href="#异步编程-Promise" class="headerlink" title="异步编程 Promise"></a>异步编程 Promise</h3><p>许多讲 Promise 的文章，喜欢提及 Promise 解决回调地狱的能力。Promise 拥有这能力，本质是它有一个 then 方法，用以访问最终的 reason 或 value 。只有当当前 promise 实例的状态不是 PENDING 时，才会去注册它的 resolve 回调或者 reject 回调。为确保回调函数会执行，要在新建 Promise 的时候显式调用 resolve 或 reject （或者使用 Promise.resolve() Promise.reject() ）</p>
<p>then 方法中，我们可以做三件事：</p>
<ol>
<li>return 一个同步的值或者是 undefined</li>
<li>return 一个 promise 对象</li>
<li>同步的 throw 一个错误</li>
</ol>
<h4 id="return-一个同步的值或者是-undefined"><a href="#return-一个同步的值或者是-undefined" class="headerlink" title="return 一个同步的值或者是 undefined"></a>return 一个同步的值或者是 undefined</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'resolve 1'</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="keyword">return</span> v1 + <span class="string">' 2'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的例子是同步 resolver ，代码走到第一个 <code>.then(...)</code> 的时候，会新建一个 promise 实例，暂且把它搁一边，记为 p2 吧。下一步异步调用回调，这里就是 <code>(v1) =&gt; {...}</code> 这个方法。入参 v1 的值是 p1 的最终 value （p1 已经 resolved）。</p>
<p><img src="p1.png" alt="sync resolver"></p>
<p>在执行 <code>(v1) =&gt; {...}</code> 回调的时候，我们得到一个返回值，它是一个同步的值。由于同步值没什么好操作的，蓝色行其实就是 handler.resolve(p2, v1+ ‘ 2’)，结果我们把 p2 的状态转为 FULFILLED ，把 p2 的 outcome 设为该同步值。</p>
<p>这一步的 return 语句很关键，没有返回值的话，p2 最终的 value 将是 undefined ，那么最后一个 then 方法是无法访问 p2 的 value 的。</p>
<p>关于异步 resolver ，道理也是一样的，牢记 then 里面的回调，只有在 promise 的状态不为 PENDING 的时候才注册。</p>
<h4 id="return-一个-promise-对象"><a href="#return-一个-promise-对象" class="headerlink" title="return 一个 promise 对象"></a>return 一个 promise 对象</h4><p>异步 resolver 可以实现 p2 等待 p1 这种效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'resolve 1'</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;   <span class="comment">// p2</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// waiting for 2s</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我希望不止 p1 可以异步 resolve，p2 也要延迟 resolve，甚至后面多写几个 <code>.then(...)</code> 这种东西，它们的 resolve 也是异步的，该怎么写？在 then 的回调参数里面没有 resolver 可以用。</p>
<p>仔细想想，p2 之所以不会延迟 resolve ，是因为我们在执行 <code>handlers.resolve(p2, value)</code> 时，我们给它传了一个同步值，p2 直接就获取到这个值。如果我们不在 then 的回调参数里面返回同步值，而是返回一个新的 promise ，这个 promise 就可以做到异步延迟 resolve/reject ，最终会有一个不变的 value 或 reason，那么 p2 的 outcome 是不是就由这个 promise 的表现决定，也具有异步特性呢？</p>
<p>还是看第一个 then 调用的时候发生了什么。前面几步和上一个例子一样，直接看 handler.resolve 这一步</p>
<p><img src="p2.png" alt="async handler"></p>
<p>这里参数 value 就是在第一个 then 的回调函数里面返回的 <code>new Promise(...)</code> ，我们判定它是一个 thenable 对象，走 if 分支，即执行  safelyResolveThenable 。</p>
<p>result 的值是 getThen 函数的结果，其实是返回 then 的调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getThen</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure we only access the accessor once as required by the spec</span></span><br><span class="line">  <span class="keyword">var</span> then = obj &amp;&amp; obj.then;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; <span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">applyThen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      then.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们提取出来的 thenable 其实就是上面的 applyThen ，顾名思义就是 promise.then 的调用。这里的 promise 绑定的是 <code>return new Promise(...)</code> 的那个，我们把它称为 dummy 吧。</p>
<p>这里有一个蛮巧妙的思路，safelyResolveThenable 的时候，self 是 p2，而 thenable 是绑定在 dummy 上的一个 then 的调用。这样讲有点拗口，我们把它看成 <code>dummy.then</code> 就好。所以 p2 的状态和 outcome，将由 dummy 决定，代码拆分如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关联 dummy 的状态和 p2 的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dummy = <span class="built_in">Promise</span>.resolve(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep 2s'</span>);</span><br><span class="line">    resolve(<span class="string">'resolve 2'</span>);</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2s 后注册 dummy 的回调</span></span><br><span class="line"><span class="comment">// dummy resolved -&gt; p2 resolved </span></span><br><span class="line"><span class="comment">// dummy.outcome -&gt; p2.outcome</span></span><br></pre></td></tr></table></figure>
<p>p2 的状态转换取决于另一个 promise，这就是异步的关键。</p>
<p>最后再看一下这段代码，里面的 then 回调都是什么时候注册的？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="comment">// p1</span></span><br><span class="line">  resolve(<span class="string">'resolve 1'</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v1</span>) =&gt;</span> &#123;                   <span class="comment">// p2</span></span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="comment">// dummy</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'sleep 2s'</span>);</span><br><span class="line">      resolve(<span class="string">'resolve 2'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">v2</span>) =&gt;</span> &#123;                   </span><br><span class="line">  <span class="built_in">console</span>.log(v2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注册顺序：</p>
<p>p1</p>
<p>2s后 dummy resolved，p2 注册回调</p>
<h4 id="基于-promise-的异步队列"><a href="#基于-promise-的异步队列" class="headerlink" title="基于 promise 的异步队列"></a>基于 promise 的异步队列</h4><p>有了上面 then 回调中返回 promise 的技巧，很容易实现一个异步队列。保持一个 promise实例，每次 then 注册的回调都是返回 new Promise，那么靠后的 then 回调的注册依赖前一个 promise 的状态。</p>
<p>比如这个题目：</p>
<p>要求1：按以下要求输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">human(<span class="string">'Jack'</span>).eat().sleep(<span class="number">5</span>).go().rest(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// I am Jack</span></span><br><span class="line"><span class="comment">// Eat</span></span><br><span class="line"><span class="comment">// 等 5 秒</span></span><br><span class="line"><span class="comment">// Sleep 1s</span></span><br><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="comment">// 等 10 秒</span></span><br><span class="line"><span class="comment">// Rest 10s</span></span><br></pre></td></tr></table></figure>
<p>要求2：eat/sleep/go/rest可以改变任意顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">human(<span class="string">'Jack'</span>).sleep(<span class="number">5</span>).eat().rest(<span class="number">10</span>).go();</span><br></pre></td></tr></table></figure>
<p>在每次调用 sleep、rest 这种带有定时的操作的时候，我们希望下一个操作会被阻塞，直到当前的操作执行完毕后，下一个操作才会被执行，这种情况就和上面的 then 回调返回一个异步 resolve 的 promise 的节奏是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting();</span><br><span class="line">  <span class="keyword">this</span>.queue = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">human</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Human(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue = <span class="keyword">this</span>.queue.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Eat'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.go = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue = <span class="keyword">this</span>.queue.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Go'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.sleep = <span class="function"><span class="keyword">function</span>(<span class="params">sec</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue = <span class="keyword">this</span>.queue.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Sleep <span class="subst">$&#123;sec&#125;</span>s`</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;, sec * <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.rest = <span class="function"><span class="keyword">function</span>(<span class="params">sec</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.queue = <span class="keyword">this</span>.queue.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Rest <span class="subst">$&#123;sec&#125;</span>s`</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;, sec * <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-工厂"><a href="#Promise-工厂" class="headerlink" title="Promise 工厂"></a>Promise 工厂</h3><p>本段选自 <a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">We have a problem with promises</a>，有删改。</p>
<p>假如你要一个接一个地执行一系列 promise ，类似 <code>Promise.all()</code> 的功能，但是不是并行的，你可能一时天真写下这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是结果并非预期，传入 <code>executeSequentially()</code> 的一系列 promises 会并行执行。原因是你不应当在 promises 这个数组层级上操作，对每一个 promise 而言，一旦被创建，它就要开始执行了，这里你需要的是一个 promise 工厂：只有在调用的时候才创建 promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>promise 工厂是一个很简单的函数，它返回一个 promise 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们拆开 <code>result = result.then(promiseFactory)</code> 的壳子，它其实就是 <code>Promise.resolve().then(promiseFactory[0]).then(promiseFactory[1]).then(...)</code> ，promiseFactory 是什么？是一个返回 promise 的函数。所以这种方式和上边的[基于 promise 的异步队列]，是一样的。</p>
<p>来看一个题目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现mergePromise函数，把传进去的数组顺序先后执行，</span></span><br><span class="line"><span class="comment">//并且把返回的数据先后放到数组data中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span>(<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line"><span class="comment">//todo 补全函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>其实题目中已经写好了 promise 工厂，ajax1，ajax2，ajax3 每一个都是创建 promise 的工厂——它们的返回值都是一个 <code>new Promise(...)</code> 的操作，所以把 <code>return ajax1()</code> 写在 then 的回调函数里面就好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergePromise</span>(<span class="params">ajaxArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  ajaxArray.forEach(<span class="function">(<span class="params">ajax</span>) =&gt;</span> &#123;</span><br><span class="line">    p = p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ajax().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">          result.push(data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">ajaxArray.forEach(<span class="function">(<span class="params">ajax</span>) =&gt;</span> &#123;</span><br><span class="line">  p = p.then(ajax).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    result.push(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章</p>
<p><a href="http://efe.baidu.com/blog/promises-anti-pattern/" target="_blank" rel="noopener">谈谈使用 promise 时候的一些反模式</a></p>
<p><a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="noopener">We have a problem with promises</a></p>
</blockquote>
]]></content>
      <categories>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>xss 和 csrf 防范</title>
    <url>/2020/07/12/xss-and-csrf/</url>
    <content><![CDATA[<h3 id="XSS-and-CSRF"><a href="#XSS-and-CSRF" class="headerlink" title="XSS and CSRF"></a>XSS and CSRF</h3><p>来自维基百科：</p>
<ul>
<li><strong>CSS</strong> </li>
</ul>
<p>跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p>
<p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<ul>
<li><strong>CSRF</strong></li>
</ul>
<p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。[1] 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<h4 id="XSS-攻击方法及防范"><a href="#XSS-攻击方法及防范" class="headerlink" title="XSS 攻击方法及防范"></a>XSS 攻击方法及防范</h4><p>XSS 大致可以分为两类：反射型 XSS 和储存型 XSS 。</p>
<ul>
<li>反射型 XSS</li>
</ul>
<p>被动的非持久性XSS。诱骗用户点击URL带攻击代码的链接，服务器解析后响应，在返回的响应内容中隐藏和嵌入攻击者的XSS代码，被浏览器执行，从而攻击用户。<br>URL可能被用户怀疑，但是可以通过短网址服务将之缩短，从而隐藏自己。</p>
<ul>
<li>储存型 XSS</li>
</ul>
<p>主动提交恶意数据到服务器，攻击者在数据中嵌入代码，这样当其他用户请求后，服务器从数据库中查询数据并发给用户，用户浏览此类页面时就可能受到攻击。典型的例子是留言板。</p>
<p>还有 DOM-based XSS（基于 DOM 的 XSS），一般是攻击者通过代码注入（输入框，留言板）执行恶意代码，盗取 cookie ，获取敏感信息，进一步发起 CSRF 。</p>
<p>防范：</p>
<ul>
<li>用户输入过滤。对用户提交的数据进行有效性验证，仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据</li>
<li>用户输出转义，当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS特殊字符，为了确保输出内容的完整性和正确性，输出HTML属性时可以使用HTML转义编码（HTMLEncode）进行处理，输出到 <code>&lt;script&gt;</code> 中，可以进行JS编码。现在主流框架 Vue，React，或者衍生的 UI 框架，其实都有对输入输出做 XSS 防范。</li>
<li>将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。【这种方法其实不是避免 XSS ，只是减小了可能的危害】</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP</a>指定页面有哪些资源允许有哪些来源，可以通过请求头的<code>Content-Security-Policy</code>头部，或html文档的meta标签实现。如下是掘金某篇博文的html文档header。<br><img src="xss1.png" alt=""></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/%E5%AD%90%E8%B5%84%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">SRI</a>在第三方 CDN 服务被入侵或回源被运营商劫持、文件内容被加入恶意代码时，网站如果启用了 SRI 策略，那么在支持 SRI 的浏览器下，被篡改的文件无法执行。</p>
<ul>
<li>对外链资源（这里是script，当然link标签也可以）使用特定算法A生成一个哈希值B，B经base64编码得到C.将<code>${A}-${C}</code><br>注入到script标签的<code>integrity</code>属性。例如：github的SRI策略<br><img src="SRI.png" alt=""><br>上图<code>sha512</code>是使用的哈希算法。 <code>-</code>后面的是编码后的哈希值。浏览器发现script标签有integrity属性，会用<code>sha512</code>计算这个script文件的哈希值，并base64编码后，和integrity的编码结果做比较。只有完全匹配才会通过校验并加载资源</li>
<li>SRI是一种“宁为玉碎，不为瓦全”的态度了，但是如果重要脚本被劫持而无法执行，可能会使得整站功能不可用。可以使用fallback方法，改为加载本站资源</li>
</ul>
</li>
</ul>
<p><a href="https://coolshell.cn/articles/4914.html" target="_blank" rel="noopener">2011年新浪微博的 XSS 攻击</a>是储存型 XSS 。其利用了微博广场页面 <a href="http://weibo.com/pub/star" target="_blank" rel="noopener">http://weibo.com/pub/star</a> 的一个URL注入了js脚本，其通过 <a href="http://163.fm/PxZHoxn" target="_blank" rel="noopener">http://163.fm/PxZHoxn</a> 短链接服务，将链接指向：</p>
<p><a href="http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%20src=//www.2kt.cn/images/t.js%3E%3C/script%3E?type=update" target="_blank" rel="noopener">http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%20src=//www.2kt.cn/images/t.js%3E%3C/script%3E?type=update</a></p>
<p>注意，上面URL链接中的其实就是 <code>&lt;script src=//www.2kt.cn/images/t.js&gt;&lt;/script&gt;</code>。</p>
<p>点击这个链接的用户会自动发一条类似“郭美美事件的一些未注意到的细节 <a href="https://t.cn/amsDE”" target="_blank" rel="noopener">https://t.cn/amsDE”</a> 的微博（博文中的链接是一个新的 evil url，一旦其他用户点击，就会把类似链接传递下去）。</p>
<h4 id="CSRF-攻击方法和防范"><a href="#CSRF-攻击方法和防范" class="headerlink" title="CSRF 攻击方法和防范"></a>CSRF 攻击方法和防范</h4><p>以下内容译自 <a href="http://www.veracode.com/security/csrf" target="_blank" rel="noopener">CROSS-SITE REQUEST FORGERY GUIDE: LEARN ALL ABOUT CSRF ATTACKS AND CSRF PROTECTION</a></p>
<p>CSRF：恶意网站向一个 Web app 发出请求，而用户已经在别的站点认证了这个 Web 程序。用这种方法，攻击者可以通过用户信任的浏览器，访问目标 web app 的功能。被攻击的目标包括 Web app，比如社交媒体，浏览器邮件客户端，网银和网络设备的 Web 界面。</p>
<hr>
<h5 id="CSRF-的关键概念"><a href="#CSRF-的关键概念" class="headerlink" title="CSRF 的关键概念"></a>CSRF 的关键概念</h5><ul>
<li>恶意请求从用户访问的站点发送到攻击者觉得经过受害者认证的其他站点。</li>
<li>通过目标站点身份验证的恶意请求，经受害者的浏览器被发送到目标站点。</li>
<li>漏洞存在于受影响的 Web app 中，而不是受害者的浏览器或托管CSRF的站点。</li>
</ul>
<hr>
<h5 id="执行一次-CSRF-攻击"><a href="#执行一次-CSRF-攻击" class="headerlink" title="执行一次 CSRF 攻击"></a>执行一次 CSRF 攻击</h5><p>CSRF 中，攻击者利用了目标 Web app 的身份认证机制。一次 CSRF 中，受害者必须通过目标站点的身份认证（登陆）。举个例子，网银 <code>examplebank.com</code> 有 CSRF 漏洞，如果我浏览这个站点上藏有 CSRF 隐患的页面，但是我没有登录，那么无事发生。假如我登录了，攻击中的请求将被执行，看起来就好像是我做的一样。（浏览器无法辨别用户是否主动请求）。</p>
<p>接下来讲一下，上面的攻击的细节。首先假设我在 <code>examplebank.com</code> 登陆了我的帐号，所以我可以做一些网上银行操作，包括转账。</p>
<p>现在我碰巧访问了 <code>somemalicioussite.com</code> ，这个站点攻击 <code>examplebank.com</code> 的用户，并且在本站设置了一个 CSRF 攻击，中招的用户会向帐号 123456789 转帐 $1,500.00 。在 <code>somemalicioussite.com</code> 的某个地方，攻击者加了这样一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"//www.veracode.com/%3Ca%20href%3D"</span>http:<span class="comment">//examplebank.com/app/transferFunds?amount=1500&amp;destinationAccount=123456789"&gt;http://examplebank.com/app/transferFunds?amount=1500&amp;destinationAccount=..." &gt;</span></span><br></pre></td></tr></table></figure>
<p>通过加载这个 iframe ，我的浏览器会向 <code>examplebank.com</code> 发送一条转账请求，因为我已经在 <code>examplebank.com</code> 登陆了，所以请求将被执行，$1,500.00 转给了帐号 123456789 。</p>
<hr>
<h5 id="另一个-CSRF-例子"><a href="#另一个-CSRF-例子" class="headerlink" title="另一个 CSRF 例子"></a>另一个 CSRF 例子</h5><p>我买了一个新的家居无线路由器。同诸多 wifi 路由器，它通过一个 web 界面设置参数。我收到路由器的时候，它有一个内置 IP 地址 192.168.1.1 。我正不知如何设置路由器，刚好 <code>somemalicioussite.com</code> 上面有一个帖子有相关教程。攻击者在这个教程里面为我的路由器添加了一个代理，指向服务 123.45.67.89 ，以后通过路由器的流量都会经过这个代理，包括密码，sessionId。</p>
<p>当我点击这个教程的时候，我忽略了一张加载失败的 1px 的小图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=”http:<span class="comment">//192.168.1.1/admin/config/outsideInterface?nexthop=123.45.67.89” alt=”pwned” height=”1” width=”1”/&gt;</span></span><br></pre></td></tr></table></figure>
<p>攻击者知道我正在读他们的教程，我会登陆路由器设置界面，所以他们把 CSRF 攻击藏在教程里面。有了上面的设置，我的路由会被添加一个代理服务器，所有经过路由器的流量也会经过这个代理服务器，攻击者就可以搞坏事了。</p>
<hr>
<h5 id="预防-CSRF"><a href="#预防-CSRF" class="headerlink" title="预防 CSRF"></a>预防 CSRF</h5><ul>
<li>修改请求不要使用 GET ，暴露参数</li>
<li>img/script 标签可以跨域，能带上cookie，并且还支持除GET之外的其它方式。所以这种方式也是能实现CSRF的</li>
</ul>
<p>方法一是每次请求都要在参数里面显示地带上token即登陆的票，虽然跨域请求能带上cookie，但是通过document.cookie仍然是获取不到其它源的cookie的，所以攻击者无法在代码里面拿到cookie里面的token，所以就没办法了。方法一的缺点是会暴露token，所以需要带token的最好不能是GET，因为GET会把参数拼在url里面，用户可能会无意把链接发给别人，但不知道这个链接带上了自己的登陆信息。</p>
<p>方法二是每次转账请求前都先请求一个随机串，这个串只能用一次转账或者支付请求，用完就废弃，只有这个串对得上才能请求成功，攻击者是无法拿到这个串的，因为如果跨域请求带cookie，浏览器要求Access-Control-Allow-Origin不能为通配符，只能为指定的源。</p>
<blockquote>
<p>参考文章</p>
</blockquote>
<blockquote>
<p><a href="https://www.imooc.com/article/13553" target="_blank" rel="noopener">对于跨站脚本攻击（XSS攻击）的理解和总结</a></p>
<p><a href="https://www.zhihu.com/question/21289758" target="_blank" rel="noopener">存储型XSS与反射型XSS有什么区别？</a></p>
<p><a href="https://coolshell.cn/articles/4914.html" target="_blank" rel="noopener">新浪微博的XSS攻击</a></p>
<p><a href="http://www.veracode.com/security/csrf" target="_blank" rel="noopener">CROSS-SITE REQUEST FORGERY GUIDE: LEARN ALL ABOUT CSRF ATTACKS AND CSRF PROTECTION</a></p>
<p><a href="https://fed.renren.com/2018/01/20/cross-origin/" target="_blank" rel="noopener">我知道的跨域与安全</a></p>
<p><a href="https://juejin.im/entry/5b82b5e56fb9a01a02311b27" target="_blank" rel="noopener">Content Security Policy (CSP) 介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>安全</tag>
      </tags>
  </entry>
</search>
