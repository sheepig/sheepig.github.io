<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.png?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="forever young">
<meta property="og:type" content="website">
<meta property="og:title" content="xqyoung&#39;s blog">
<meta property="og:url" content="http://www.xqyoung.com/index.html">
<meta property="og:site_name" content="xqyoung&#39;s blog">
<meta property="og:description" content="forever young">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xqyoung&#39;s blog">
<meta name="twitter:description" content="forever young">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.xqyoung.com/">





  <title>xqyoung's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xqyoung's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">coding is fun</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.xqyoung.com/2018/11/19/async-render/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xqyoung">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/woodstock.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xqyoung's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/async-render/" itemprop="url">同步渲染和异步渲染对 DOM 的阻塞</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T20:58:16+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/优化/" itemprop="url" rel="index">
                    <span itemprop="name">优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>首先区分一下，什么是同步渲染和异步渲染。</p>
<p>同步：浏览器访问网址，浏览器创建新的tabpage，新的内存块，加载页面的全部资源并渲染全部资源。但只要有页面中的任何一个操作，就会从新的开端全部在创建请求渲染一次，浏览器自己控制的http。</p>
<p>异步：用之前已经渲染过的页面数据，与后台交互数据不需要重新来渲染页面，实现对页面的部分更新。这里主要讲动态插入 HTML 标签的异步渲染。</p>
<h3 id="同步渲染"><a href="#同步渲染" class="headerlink" title="同步渲染"></a>同步渲染</h3><p>一般我们会把样式写在 HTML 头部，页面脚本放在 <code>&lt;/body&gt;</code> 之前，因为样式和脚本会阻塞 DOM 渲染，但是样式不阻塞 DOM 解析。</p>
<p>以下是 Webkit 解析资源，最终呈现页面的主流程</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="Webkit&#39;s process"></p>
<h4 id="脚本和样式表的处理顺序"><a href="#脚本和样式表的处理顺序" class="headerlink" title="脚本和样式表的处理顺序"></a>脚本和样式表的处理顺序</h4><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><p>解析 HTML 文件过程中，解析器遇到 <code>&lt;script&gt;</code>标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>
<h5 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h5><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>
<h5 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h5><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>
<hr>
<h4 id="CSS-阻塞-DOM-渲染"><a href="#CSS-阻塞-DOM-渲染" class="headerlink" title="CSS 阻塞 DOM 渲染"></a>CSS 阻塞 DOM 渲染</h4><p>这里需要区分 DOM 解析（parsing）和 DOM 渲染 （rendering）。准确来说，是 HTML Parsing 和 DOM Rendering 。无论是外链 CSS 还是内联 CSS ，都会阻塞 Rendering ，也就是说这部分 CSS 在下载并解析结束之前，它后面的 HTML 都不会显示。这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。</p>
<p>CSS 阻塞 Rendering 的最直接结果，就是延迟脚本执行和 DOMContentLoaded 事件触发。但是，不同的渲染引擎对此处理不一样，Presto (Opera)就不会延迟脚本的执行。</p>
<p>有些情况下，可以尝试添加媒体查询来避免不必要的阻塞。 尤其是响应式站点可以做此优化：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"other.css"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"(min-width: 40em)"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>看一个栗子</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h2&gt;Hello&lt;/h2&gt;</span><br><span class="line">  &lt;script&gt; </span><br><span class="line">    <span class="function">function <span class="title">printH2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        console.log(<span class="string">'first script'</span>, document.querySelectorAll(<span class="string">'h2'</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    printH2();</span><br><span class="line">    setTimeout(printH2);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"http://cdn.bootcss.com/bootstrap/4.0.0-alpha.4/css/bootstrap.css"</span>&gt;</span><br><span class="line">  &lt;h2&gt;World&lt;/h2&gt;</span><br><span class="line">  &lt;script&gt; console.log(<span class="string">'second script'</span>); &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在 Chrome 开发者工具中开启 <code>Disable Cache</code> 和 <code>Throttling</code> 来模拟较慢的网络。</p>
<p><img src="render1.png" alt=""></p>
<p><img src="render2.png" alt=""></p>
<p>可以看到 document(HTML) 花了 2.01s 加载，加载完成后，页面还未渲染。</p>
<p>第一次输出只有一个 <code>&lt;h2&gt;</code> ，说明脚本执行会阻塞 DOM 解析。</p>
<p>第二次输出有两个 <code>&lt;h2&gt;</code> ，说明样式不会阻塞 DOM 解析。</p>
<p>控制台已经打印出 <code>h2</code> ，页面还是空白，说明样式会阻塞 DOM 渲染。</p>
<p>2.01s 后，<code>&#39;second script&#39;</code> 没有被打印出来，说明样式会阻塞脚本。</p>
<p>但是一般人不会去 <code>Disable Cache</code> ，那么如果在允许缓存的情况下，样式表已经缓存过，那句 <code>setTimeout(printH2);</code> 还会在样式加载结束后才打印吗？不同渲染引擎对此处理不同，前文有提到，Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。本次实验是在 Chrome 上进行的，反复刷新了几遍后，终于有这样一个结果：</p>
<p><img src="render3.png" alt=""></p>
<hr>
<h4 id="脚本阻塞-DOM-解析-渲染"><a href="#脚本阻塞-DOM-解析-渲染" class="headerlink" title="脚本阻塞 DOM 解析+渲染"></a>脚本阻塞 DOM 解析+渲染</h4><p>同步渲染模式下，无论是内联的脚本还是外链的脚本，都会阻塞 DOM Parsing ，<code>DOMContentLoaded</code> 事件会被延迟，DOM Rendering 自然也被阻塞。由于 JavaScript 只会阻塞后续的 DOM，前面的 DOM 在解析完成后会被立即渲染给用户。 这也是为什么我们把脚本放在页面底部：脚本仍在下载时页面已经可以正常地显示了。</p>
<hr>
<h3 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h3><h4 id="外链样式表"><a href="#外链样式表" class="headerlink" title="外链样式表"></a>外链样式表</h4><p>动态插入的外链样式表不阻塞 DOM Rendering ，当然也不阻塞 DOM Parsing 。</p>
<p>打开一个任何一个页面，在控制台输入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">link.rel = <span class="string">'stylesheet'</span>;</span><br><span class="line">link.href = <span class="string">'https://cdn.bootcss.com/animate.css/3.5.2/animate.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.text = <span class="string">'console.log("after link[rel=stylesheet]")'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h2 = <span class="built_in">document</span>.createElement(<span class="string">'h2'</span>);</span><br><span class="line">h2.innerHTML = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(h2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题外话：例子是直接引用参考文章的，文章中外链的 CSS 样式的 Url 里面的协议是 HTTP，在 HTTPS 的网页注入这段代码，外链会被 block 掉。<a href="https://www.jianshu.com/p/c195b4adaec1" target="_blank" rel="noopener">https 页面中引入 http 资源的解决方式</a></p>
</blockquote>
<p>在外链样式表还在下载时，脚本已经执行，文本也已经渲染。</p>
<p><img src="render4.png" alt=""></p>
<hr>
<h4 id="内联样式表"><a href="#内联样式表" class="headerlink" title="内联样式表"></a>内联样式表</h4><p>与外链样式表不同，内联样式表会阻塞DOM解析（当然渲染也会被阻塞）。 其实不能叫阻塞啦，因为不涉及网络请求，内联样式表的解析本来就是同步的。</p>
<p>我们可以通过 <code>document.styleSheets</code> 来检测样式表是否已经解析（Parse）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">style.textContent = <span class="string">'*&#123; color: red &#125;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.head.innerHTML = <span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.styleSheets.length);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(style);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>].rules[<span class="number">0</span>].cssText);</span><br></pre></td></tr></table></figure>
<p><img src="render5.png" alt=""></p>
<p>第一处 console.log: <code>&lt;style&gt;</code> 尚未插入 DOM 树的时候，样式表的数目为零。</p>
<p>第二处 console.log: 插入 <code>&lt;style&gt;</code> 标签后，立刻读取被解析的 CSS 规则。</p>
<p>总结：</p>
<ul>
<li>未插入 DOM 树的 内联样式不会被解析</li>
<li>插入后样式表会被立即解析，甚至不会进入下一个<a href="https://html.spec.whatwg.org/#event-loops" target="_blank" rel="noopener">事件循环</a>。也就是说，<code>document.body.appendChild(style);</code> 执行完之后，进入样式表解析。最后一句 console.log 要一直等待样式解析完成才会执行。如果样式表十分庞大，阻塞将十分明显。</li>
</ul>
<hr>
<h4 id="外链脚本"><a href="#外链脚本" class="headerlink" title="外链脚本"></a>外链脚本</h4><p>动态插入的外部脚本的载入是异步的，不会阻塞解析或者渲染。 这意味着动态插入一个外部脚本后不可立即使用其内容，需要等待加载完毕。 例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'https://cdn.bootcss.com/react/15.4.0/react.js'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after script'</span>, <span class="built_in">window</span>.React);</span><br></pre></td></tr></table></figure>
<p><img src="render6.png" alt=""></p>
<p><code>window.React</code> 会为空，等到外链资源加载完成后才可用。</p>
<h4 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h4><p>内联脚本的表现和内联样式基本一样，阻塞 DOM parsing，阻塞后续脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.text = <span class="string">"console.log('from script');"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before script'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after script'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="render7.png" alt=""></p>
<h4 id="资源载入事件"><a href="#资源载入事件" class="headerlink" title="资源载入事件"></a>资源载入事件</h4><p>脚本和样式载入事件可以直接监听到，当然这只对非阻塞的资源获取有效。 需要注意的是浏览器兼容性：绝大多数情况监听 <code>onload</code> 和 <code>onerror</code> 即可， 为了支持IE浏览器，可以监听 <code>onreadystatechange</code> 事件。</p>
<hr>
<p>总结：</p>
<ul>
<li>未插入到 DOM 树的外链样式/脚本，不会发起网络请求，更不会对 DOM Parsing/Rendering 有什么影响。</li>
<li>同步模式下（文档已自带的 style、script 标签），内联样式表/脚本阻塞 DOM parsing ，外链样式表不阻塞 DOM parsing，但是阻塞 DOM rendering ；没有 async，defer 等标记的“裸奔”外链脚本，阻塞 DOM parsing 。</li>
<li>异步模式下（动态添加 style、script 标签）外链样式表/脚本不阻塞 DOM Parsing 和 DOM Rendering 。这意味着要等它们下载完才可用。内联样式表/脚本阻塞 DOM Parsing/Rendering ，阻塞后续脚本（不会进入事件循环，这一点和同步模式一样）。</li>
</ul>
<hr>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>外链样式脚本放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中，因为外链样式不阻塞 DOM 解析，这样做也可以避免样式跳动。</li>
<li>对整个页面样式的调整（会触发回流）如调整 rem 计算策略的 script 脚本，可以放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中，这里可以用内联的方法（虽然不是最佳），阻塞后续 DOM 解析，避免样式跳动。也可以用外链脚本， 加上 <code>async</code> 标签可以让脚本的下载不占用 DOM 解析线程，在下载完后立刻执行。</li>
<li>使用 CDN 。不局限于样式和脚本，图片也可以。</li>
<li>样式、图片使用外域，因为浏览器有最大并行下载数限制。解析见<a href="https://webmasters.stackexchange.com/questions/26753/why-do-big-sites-host-their-images-css-on-external-domains" target="_blank" rel="noopener">Why do big sites host their images/css on external domains?</a></li>
<li><code>async</code> <code>defer</code> <code>preload</code> <code>prefetch</code>。前两个只能作用于脚本</li>
</ul>
<p><img src="https://image-static.segmentfault.com/215/179/2151798436-59da4801c6772_articlex" alt="async vs defer"></p>
<p>没有标记加载策略的 <code>script</code> 和 <code>async</code> 都会阻塞 DOM 解析，不同在于 <code>async</code> 的下载相对于 DOM 解析是异步的。<code>defer</code> 的下载也是异步的，但是下载结束后不立刻执行，而且还会按照 <code>script</code> 标签的顺序执行。（这一点 <code>async</code> 就不能保证）。</p>
<blockquote>
<p>参考文章<br><a href="https://harttle.land/2016/11/26/static-dom-render-blocking.html" target="_blank" rel="noopener">CSS/JS 阻塞 DOM 解析和渲染</a><br><a href="https://harttle.land/2016/11/26/dynamic-dom-render-blocking.html" target="_blank" rel="noopener">异步渲染的下载和阻塞行为</a><br><a href="http://www.qingpingshan.com/m/view.php?aid=169704" target="_blank" rel="noopener">异步渲染DOM元素的加载时机</a><br><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets" target="_blank" rel="noopener">How Browsers Work: Behind the scenes of modern web browsers #The order of processing scripts and style sheets</a><br><a href="https://mp.weixin.qq.com/s/5cnZ9_67-Ikwg4GQ-2nhuw" target="_blank" rel="noopener">有一种优化，叫Preload</a><br><a href="https://cloud.tencent.com/document/product/228/2939#.E5.8A.A0.E9.80.9F.E5.8E.9F.E7.90.86" target="_blank" rel="noopener">Tencent CDN</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.xqyoung.com/2018/11/19/css-animation-and-gpu-accelerated/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xqyoung">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/woodstock.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xqyoung's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/css-animation-and-gpu-accelerated/" itemprop="url">css 动画和硬件加速</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T20:53:27+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/优化/" itemprop="url" rel="index">
                    <span itemprop="name">优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="什么是动画"><a href="#什么是动画" class="headerlink" title="什么是动画"></a>什么是动画</h2><p>浏览器的动画原理和翻页动画类似，通过不断更新绘制 DOM 和 CSS 形成的动画，绘制的速度够快，人眼就察觉不出每一帧的间隔，视觉上就是连续的动画。大部分浏览器的刷新频率为 60Hz ，也就是一秒 60 帧。setInterval 或 setTimeout 做的动画根据人为定义的时间间隔绘制，如果间隔定义小于浏览器显示频率（16.7ms）假设为10ms，就会导致第三帧丢失。</p>
<p><img src="http://www.mrfront.com/wp-content/uploads/2016/09/flip-animation-1.gif" alt="animation"></p>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>在 css transition 之前，css 是没有时间轴的，也就是说，所有的状态变化，在一瞬间完成。有了 transition 之后，可以定义一个控件从一个状态过渡到另一个状态的“过渡过程”，浏览器会在过渡过程中填充一连串连续帧。transition 要求控件有明确的开始状态和结束状态，比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</p>
<p>过渡效果被限制在始末两个状态，这决定了它们会缺少动效那样的细节处理，但同时它实现起来也更容易。</p>
<h3 id="使用-transition"><a href="#使用-transition" class="headerlink" title="使用 transition"></a>使用 transition</h3><p>CSS transitions 可以决定哪些属性发生动画效果 (明确地列出这些属性)，何时开始 (设置 delay），持续多久 (设置 duration) 以及如何动画 (定义timing funtion，比如匀速地或先快后慢)。</p>
<p>并不是所有的 css 属性都可以动画。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties" target="_blank" rel="noopener">可动画属性列表</a>是一个有限集合。</p>
<p>定义一个过渡效果，有以下 css 属性：</p>
<ul>
<li>transition-property 指定哪个或哪些 CSS 属性用于过渡。只有指定的属性才会在过渡中发生动画，其它属性仍如通常那样瞬间变化。</li>
<li>transition-duration 指定过渡的时长。或者为所有属性指定一个值，或者指定多个值，为每个属性指定不同的时长。</li>
<li>transition-timing-function 指定一个函数，定义属性值怎么变化。缓动函数 Timing functions 定义属性如何计算。</li>
<li>transition-delay 指定延迟，即属性开始变化时与过渡开始发生时之间的时长。</li>
</ul>
<p>简写语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>transition 有许多限制，比如：</p>
<ul>
<li>控件的状态只有两个：开始状态和结束状态</li>
<li>transition 的具体动画效果是绑定在具体控件上的，如果想要为多个元素声明同样的 transition ，需要为所有元素书写 transition 属性。</li>
<li>过渡效果需要事件触发，如 hover，元素淡入淡出。</li>
<li>transition 一般只发生一次，不会重复触发。</li>
</ul>
<p>animation（动效） 则可以解决以上问题。动效可以让你添加很多中间状态，并提供了更高的控制程度，而不必依赖于始末两个状态。</p>
<h3 id="使用-animation"><a href="#使用-animation" class="headerlink" title="使用 animation"></a>使用 animation</h3><p>动效是通过对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes" target="_blank" rel="noopener">keyframes（关键帧）</a>的使用设置实现的。过渡效果能在一个类中的一行被指定，而动效能在 CSS 里单独用一系列关键帧被指定。</p>
<p>定义动效的 css 属性：</p>
<ul>
<li>animation-name 指定应用的一系列动画，每个名称代表一个由 @keyframes 定义的动画序列。</li>
<li>animation-duration 指定一个动画周期的时长。默认值是 0s ，表示无动画。</li>
<li>animation-timing-function 定义CSS动画在每一动画周期中执行的节奏。可能值为一或多个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/timing-function" target="_blank" rel="noopener"><timing-function></timing-function></a>。</li>
<li>animation-delay 定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。默认值 0s 代表动画在应用到元素上后立即开始执行。</li>
<li>animation-iteration-count 定义动画在结束前运行的次数。可以是1次，可以是无限循环。默认值是 1 。</li>
<li>animation-direction 指示动画是否反向播放。</li>
<li>animation-fill-mode 指定在动画执行之前和之后如何给动画的目标应用样式。</li>
<li>animation-play-state 定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。默认值是 running 。</li>
</ul>
<p>当相关 animation 属性不多，可以简写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: &lt;name&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt; &lt;iteration-count&gt; &lt;direction&gt;</span><br></pre></td></tr></table></figure>
<h3 id="js-动画"><a href="#js-动画" class="headerlink" title="js 动画"></a>js 动画</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame()</a> 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</p>
<h2 id="动画和性能"><a href="#动画和性能" class="headerlink" title="动画和性能"></a>动画和性能</h2><p>关于 css 硬件加速，查到的资料大概都是16年之前的（那时的 Chrome 还有 Timeline 面板=。=现在应该叫 Performance 了）。<br>资料如下：</p>
<blockquote>
<p><a href="http://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/" target="_blank" rel="noopener">CSS硬件加速的好与坏</a></p>
<p><a href="https://www.aliyun.com/jiaocheng/664245.html" target="_blank" rel="noopener">CSS动画之硬件加速</a></p>
</blockquote>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">css 层叠上下文</a> 或者说图层，是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p>
<ul>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ul>
<p>每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</p>
<h3 id="top-absolute-实现的动画"><a href="#top-absolute-实现的动画" class="headerlink" title="top + absolute 实现的动画"></a>top + absolute 实现的动画</h3><p>我写了一个 <a href="https://codepen.io/sheepig-the-bashful/full/ZMNbJM" target="_blank" rel="noopener">demo</a>，点击 click ，盒子的 left 变为 200px 。transition 定义的过渡。</p>
<p><img src="transition-repaint.png" alt="transition repaint"></p>
<p>动画的执行的过程中，发生了多次 repaint 。</p>
<p><img src="transition-absolute.png" alt="transition using absolute"></p>
<p>查看主线程，主线程做了很多次 paint 。</p>
<p><img src="main-paint.png" alt="paint"></p>
<p>如果在 chrome 开发者工具中开启 Rendering 面板的 “Painting flashing”，页面中 repaint 区域会被绿色蒙板高亮出来。可以看到动画过渡过程中，灰色盒子有一层闪烁的绿色蒙板。</p>
<p><img src="green-cover.png" alt="green cover"></p>
<p>绝对定位会建立一个新的图层，而此图层上只有当前一个元素，多以只会 repaint ，而不会 reflow 。</p>
<p>在这个例子中，对于动画的每一帧，浏览器会计算元素的几何形状，渲染新状态的图像，并把它们发送给GPU。尽管浏览器做了优化，在repaint时，只会repaint部分区域，但是我们的动画仍然不够流畅。如果这时在主线程运行一些耗时的任务，动画的帧数可能远达不到 60 帧，甚至低于人眼对帧数的分辨率，视觉上出现“卡顿”效果。</p>
<h3 id="transform-实现的动画"><a href="#transform-实现的动画" class="headerlink" title="transform 实现的动画"></a>transform 实现的动画</h3><p>用 transform 改写上面的例子，得到渲染过程如下：</p>
<p><img src="transition-transform.png" alt="transition transform"></p>
<p>显然浏览器花在 paint 的时间少的不止一星半点，动画演示期间并没有过多的 repaint 。简单说，<a href="https://csstriggers.com/transform" target="_blank" rel="noopener">transform</a> 不触发几何变化和绘制，它可以在 GPU 加速下，在 <strong>合成器线程（compositor thread）</strong> 中处理。</p>
<h3 id="GPU-加速"><a href="#GPU-加速" class="headerlink" title="GPU 加速"></a>GPU 加速</h3><p>浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树构建完之后，浏览器要做的就是：reflow/layout -&gt; repaint -&gt; composite 。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理。图层在 GPU 中 transform 是不会触发 repaint 的，最终这些使用 transform 的图层都会由独立的合成器线程进行处理。</p>
<p>现代浏览器大都可以利用GPU来加速页面渲染。在GPU的众多特性之中，它可以存储一定数量的纹理（一个矩形的像素点集合）并且高效地操作这些纹理（比如进行特定的移动、缩放和旋转操作）。这些特性在实现一个流畅的动画时特别有用。浏览器不会在动画的每一帧都绘制一次，而是生成DOM元素的快照，并作为GPU纹理（也被叫做层）存储起来。之后浏览器只需要告诉GPU去转换指定的纹理来实现DOM元素的动画效果。这就叫做GPU合成，也经常被称作『硬件加速』。</p>
<p>所以产生 GPU 加速的条件如下：</p>
<ol>
<li><p>动画会使它所在的元素提升为复合层（一个层叠上下文，比如绝对定位和 transform ），因此不发生 reflow 。</p>
</li>
<li><p>图层在 GPU 中不引起 repaint ，【目前只有 transform 和 opacity】，因此不发生 repaint 。</p>
</li>
</ol>
<p>另外，transform3D 和 2D 的区别在于 3D 渲染前便会产生新的图层，而 2D 是在运行时产生图层，运行结束时删除图层。</p>
<p>浏览器将a元素提升为一个复合层有很多种原因，下面列举了一些：</p>
<ul>
<li><p>3d或透视变换css属性，例如translate3d,translateZ等等（js一般通过这种方式，使元素获得复合层）</p>
</li>
<li><p><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素。</p>
</li>
<li><p>混合插件（如flash）。</p>
</li>
<li><p>元素自身的 opacity 和 transform 做 CSS 动画。</p>
</li>
<li><p>拥有css过滤器的元素。</p>
</li>
<li><p>使用will-change属性。</p>
</li>
<li><p>绝对定位</p>
</li>
<li><p>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</p>
</li>
</ul>
<h2 id="GPU-加速可能带来的问题"><a href="#GPU-加速可能带来的问题" class="headerlink" title="GPU 加速可能带来的问题"></a>GPU 加速可能带来的问题</h2><h3 id="GPU是如何合成图像的"><a href="#GPU是如何合成图像的" class="headerlink" title="GPU是如何合成图像的"></a>GPU是如何合成图像的</h3><p>GPU实际上可以看作一个独立的计算机，它有自己的处理器和存储器及数据处理模型。当浏览器向GPU发送消息的时候，就像向一个外部设备发送消息。</p>
<p>你可以把浏览器向GPU发送数据的过程，与使用ajax向服务器发送消息非常类似。想一下，你用ajax向服务器发送数据，服务器是不会直接接受浏览器的存储的信息的。你需要收集页面上的数据，把它们放进一个载体里面（例如JSON），然后发送数据到远程服务器。</p>
<p>同样的，浏览器向GPU发送数据也需要先创建一个载体；只不过GPU距离CPU很近，不会像远程服务器那样可能几千里那么远。但是对于远程服务器，2秒的延迟是可以接受的；但是对于GPU，几毫秒的延迟都会造成动画的卡顿。</p>
<p>浏览器向GPU发送的数据载体是什么样？这里给出一个简单的制作载体，并把它们发送到GPU的过程。</p>
<ul>
<li><p>画每个复合层的图像</p>
</li>
<li><p>准备图层的数据</p>
</li>
<li><p>准备动画的着色器（如果需要）</p>
</li>
<li><p>向GPU发送数据</p>
</li>
</ul>
<p>所以你可以看到，每次当你添加transform:translateZ(0)或will-change：transform给一个元素，你都会做同样的工作。重绘是非常消耗性能的，在这里它尤其缓慢。在大多数情况，浏览器不能增量重绘。它不得不重绘先前被复合层覆盖的区域。</p>
<h3 id="隐式合成"><a href="#隐式合成" class="headerlink" title="隐式合成"></a>隐式合成</h3><p><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener">https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/</a></p>
<blockquote>
<p>参考文章</p>
<p><a href="https://cssanimation.rocks/transition-vs-animation/" target="_blank" rel="noopener">Transitions vs Animations</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener">CSS动画简介</a></p>
<p><a href="https://juejin.im/post/5afaea6b6fb9a07aa34a6a74" target="_blank" rel="noopener">[译] JavaScript 是如何工作的：CSS 和 JS 动画背后的原理 + 如何优化性能</a></p>
<p><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener">CSS GPU Animation: Doing It Right</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/woodstock.jpeg" alt="xqyoung">
            
              <p class="site-author-name" itemprop="name">xqyoung</p>
              <p class="site-description motion-element" itemprop="description">forever young</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xqyoung</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
